(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{432:function(t,s,a){"use strict";a.r(s);var n=a(3),v=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("nav",{staticClass:"table-of-contents"},[s("ol",[s("li",[s("a",{attrs:{href:"#1.6-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"}},[t._v(" 1.6 请介绍全局变量和局部变量的区别")])]),s("li",[s("a",{attrs:{href:"#1.7-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"}},[t._v(" 1.7 请介绍一下实例变量的默认值")])]),s("li",[s("a",{attrs:{href:"#1.8-%E4%B8%BA%E5%95%A5%E8%A6%81%E6%9C%89%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F"}},[t._v(" 1.8 为啥要有包装类？")])]),s("li",[s("a",{attrs:{href:"#1.9-%E8%AF%B4%E4%B8%80%E8%AF%B4%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%81%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"}},[t._v(" 1.9 说一说自动装箱、自动拆箱的应用场景")])]),s("li",[s("a",{attrs:{href:"#1.10-%E5%A6%82%E4%BD%95%E5%AF%B9integer%E5%92%8Cdouble%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89%EF%BC%9F"}},[t._v(" 1.10 如何对Integer和Double类型判断相等？")])]),s("li",[s("a",{attrs:{href:"#1.11-int%E5%92%8Cinteger%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BA%8C%E8%80%85%E5%9C%A8%E5%81%9A%3D%3D%E8%BF%90%E7%AE%97%E6%97%B6%E4%BC%9A%E5%BE%97%E5%88%B0%E4%BB%80%E4%B9%88%E7%BB%93%E6%9E%9C%EF%BC%9F"}},[t._v(" 1.11 int和Integer有什么区别，二者在做==运算时会得到什么结果？")])]),s("li",[s("a",{attrs:{href:"#1.12-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"}},[t._v(" 1.12 说一说你对面向对象的理解")])]),s("li",[s("a",{attrs:{href:"#1.13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"}},[t._v(" 1.13 面向对象的三大特征是什么？")])]),s("li",[s("a",{attrs:{href:"#1.14-%E5%B0%81%E8%A3%85%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%B0%81%E8%A3%85%EF%BC%9F"}},[t._v(" 1.14 封装的目的是什么，为什么要有封装？")])]),s("li",[s("a",{attrs:{href:"#1.15-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"}},[t._v(" 1.15 说一说你对多态的理解")])])])]),s("h4",{attrs:{id:"_1-6-请介绍全局变量和局部变量的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-请介绍全局变量和局部变量的区别"}},[t._v("#")]),t._v(" 1.6 请介绍全局变量和局部变量的区别")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("Java中的变量分为成员变量和局部变量，它们的区别如下：")]),t._v(" "),s("p",[t._v("成员变量：")]),t._v(" "),s("ol",[s("li",[t._v("成员变量是在类的范围里定义的变量；")]),t._v(" "),s("li",[t._v("成员变量有默认初始值；")]),t._v(" "),s("li",[t._v("未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，生命周期与对象相同；")]),t._v(" "),s("li",[t._v("被static修饰的成员变量也叫类变量，它存储于方法区中，生命周期与当前类相同。")])]),t._v(" "),s("p",[t._v("局部变量：")]),t._v(" "),s("ol",[s("li",[t._v("局部变量是在方法里定义的变量；")]),t._v(" "),s("li",[t._v("局部变量没有默认初始值；")]),t._v(" "),s("li",[t._v("局部变量存储于栈内存中，作用的范围结束，变量空间会自动的释放。")])]),t._v(" "),s("p",[s("strong",[t._v("注意事项")])]),t._v(" "),s("p",[t._v("Java中没有真正的全局变量，面试官应该是出于其他语言的习惯说全局变量的，他的本意应该是指成员变量。")]),t._v(" "),s("h4",{attrs:{id:"_1-7-请介绍一下实例变量的默认值"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-7-请介绍一下实例变量的默认值"}},[t._v("#")]),t._v(" 1.7 请介绍一下实例变量的默认值")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("实例变量若为引用数据类型，其默认值一律为null。若为基本数据类型，其默认值如下：")]),t._v(" "),s("ul",[s("li",[t._v("byte：0")]),t._v(" "),s("li",[t._v("short：0")]),t._v(" "),s("li",[t._v("int：0")]),t._v(" "),s("li",[t._v("long：0L")]),t._v(" "),s("li",[t._v("float：0.0F")]),t._v(" "),s("li",[t._v("double：0.0")]),t._v(" "),s("li",[t._v("char：'\\u0000'")]),t._v(" "),s("li",[t._v("boolean：false")])]),t._v(" "),s("p",[s("strong",[t._v("注意事项")])]),t._v(" "),s("p",[t._v("上述默认值规则适用于所有的成员变量，所以对于类变量也是适用的。")]),t._v(" "),s("h4",{attrs:{id:"_1-8-为啥要有包装类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-8-为啥要有包装类"}},[t._v("#")]),t._v(" 1.8 为啥要有包装类？")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。")]),t._v(" "),s("p",[s("strong",[t._v("扩展阅读")])]),t._v(" "),s("p",[t._v("Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。")]),t._v(" "),s("h4",{attrs:{id:"_1-9-说一说自动装箱、自动拆箱的应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-9-说一说自动装箱、自动拆箱的应用场景"}},[t._v("#")]),t._v(" 1.9 说一说自动装箱、自动拆箱的应用场景")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("自动装箱、自动拆箱是JDK1.5提供的功能。")]),t._v(" "),s("p",[t._v("自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；")]),t._v(" "),s("p",[t._v("自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；")]),t._v(" "),s("p",[t._v("通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。比如，某个方法的参数类型为包装类型，调用时我们所持有的数据却是基本类型的值，则可以不做任何特殊的处理，直接将这个基本类型的值传入给方法即可。")]),t._v(" "),s("h4",{attrs:{id:"_1-10-如何对integer和double类型判断相等"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-10-如何对integer和double类型判断相等"}},[t._v("#")]),t._v(" 1.10 如何对Integer和Double类型判断相等？")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("Integer、Double不能直接进行比较，这包括：")]),t._v(" "),s("ul",[s("li",[t._v("不能用==进行直接比较，因为它们是不同的数据类型；")]),t._v(" "),s("li",[t._v("不能转为字符串进行比较，因为转为字符串后，浮点值带小数点，整数值不带，这样它们永远都不相等；")]),t._v(" "),s("li",[t._v("不能使用compareTo方法进行比较，虽然它们都有compareTo方法，但该方法只能对相同类型进行比较。")])]),t._v(" "),s("p",[t._v("整数、浮点类型的包装类，都继承于Number类型，而Number类型分别定义了将数字转换为byte、short、int、long、float、double的方法。所以，可以将Integer、Double先转为转换为相同的基本数据类型（如double），然后使用==进行比较。")]),t._v(" "),s("p",[s("strong",[t._v("示例代码")])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Double")]),t._v(" d "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100.00")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doubleValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" d"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("doubleValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])]),s("p",[s("strong",[t._v("补充：")])]),t._v(" "),s("p",[t._v("小数直接比较也会出现精度问题，主要看有没有出现精度损失。这里这样100.00是没有精度丢失的，所以直接比较是个true。一般如果要比较小数，不管是用double还是float都是要设置一个精度的，比如eps=1e-5。这样1e-5内的误差可以当做他们相等。")]),t._v(" "),s("h4",{attrs:{id:"_1-11-int和integer有什么区别-二者在做-运算时会得到什么结果"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-11-int和integer有什么区别-二者在做-运算时会得到什么结果"}},[t._v("#")]),t._v(" 1.11 int和Integer有什么区别，二者在做==运算时会得到什么结果？")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("int是基本数据类型，Integer是int的包装类。二者在做==运算时，Integer会自动拆箱为int类型，然后再进行比较。届时，如果两个int值相等则返回true，否则就返回false。")]),t._v(" "),s("h4",{attrs:{id:"_1-12-说一说你对面向对象的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-12-说一说你对面向对象的理解"}},[t._v("#")]),t._v(" 1.12 说一说你对面向对象的理解")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("面向对象是一种更优秀的程序设计方法，它的基本思想是使用:")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("类、")])]),t._v(" "),s("li",[s("p",[t._v("对象")])]),t._v(" "),s("li",[s("p",[t._v("继承")])]),t._v(" "),s("li",[s("p",[t._v("封装")])]),t._v(" "),s("li",[s("p",[t._v("消息")]),t._v(" "),s("p",[t._v("等基本概念进行程序设计。")])])]),t._v(" "),s("p",[t._v("它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得"),s("strong",[t._v("软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("扩展阅读")])]),t._v(" "),s("p",[s("strong",[t._v("结构化程序设计方法")]),t._v("主张按功能来分析系统需求，其主要原则可概括为自顶向下、逐步求精、模块化等。结构化程序设计首先采用结构化分析方法对系统进行需求分析，然后使用结构化设计方法对系统进行概要设计、详细设计，最后采用结构化编程方法来实现系统。")]),t._v(" "),s("p",[t._v("因为结构化程序设计方法主张按功能把软件系统逐步细分，因此这种方法也被称为面向功能的程序设计方法；结构化程序设计的每个功能都负责对数据进行一次处理，每个功能都接受一些数据，处理完后输出一些数据，这种处理方式也被称为面向数据流的处理方式。")]),t._v(" "),s("p",[t._v("结构化程序设计里最小的程序单元是函数，每个函数都负责完成一个功能，用以接收一些输入数据，函数对这些输入数据进行处理，处理结束后输出一些数据。整个软件系统由一个个函数组成，其中作为程序入口的函数被称为主函数，主函数依次调用其他普通函数，普通函数之间依次调用，从而完成整个软件系统的功能。")]),t._v(" "),s("p",[t._v("每个函数都是具有输入、输出的子系统，函数的输入数据包括函数形参、全局变量和常量等，函数的输出数据包括函数返回值以及传出参数等。结构化程序设计方式有如下两个局限性：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("设计不够直观")]),t._v("，与人类习惯思维不一致。采用结构化程序分析、设计时，开发者需要将客观世界模型分解成一个个功能，每个功能用以完成一定的数据处理。")]),t._v(" "),s("li",[s("strong",[t._v("适应性差")]),t._v("，可扩展性不强。由于结构化设计采用自顶向下的设计方式，所以当用户的需求发生改变，或需要修改现有的实现方式时，都需要自顶向下地修改模块结构，这种方式的维护成本相当高。")])]),t._v(" "),s("h4",{attrs:{id:"_1-13-面向对象的三大特征是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-13-面向对象的三大特征是什么"}},[t._v("#")]),t._v(" 1.13 面向对象的三大特征是什么？")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("面向对象的程序设计方法具有三个基本特征：")]),t._v(" "),s("ul",[s("li",[t._v("封装")]),t._v(" "),s("li",[t._v("继承")]),t._v(" "),s("li",[t._v("多态")])]),t._v(" "),s("p",[t._v("其中，")]),t._v(" "),s("ul",[s("li",[t._v("封装指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能；")]),t._v(" "),s("li",[t._v("继承是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法；")]),t._v(" "),s("li",[t._v("多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，这意味着同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。")])]),t._v(" "),s("p",[s("strong",[t._v("扩展阅读")])]),t._v(" "),s("p",[s("strong",[t._v("抽象")]),t._v("也是面向对象的重要部分，抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是考虑部分问题。例如，需要考察Person对象时，不可能在程序中把Person的所有细节都定义出来，通常只能定义Person的部分数据、部分行为特征，而这些数据、行为特征是软件系统所关心的部分。")]),t._v(" "),s("h4",{attrs:{id:"_1-14-封装的目的是什么-为什么要有封装"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-14-封装的目的是什么-为什么要有封装"}},[t._v("#")]),t._v(" 1.14 封装的目的是什么，为什么要有封装？")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("封装是面向对象编程语言"),s("strong",[t._v("对客观世界的模拟")]),t._v("，在客观世界里，对象的状态信息都被隐藏在对象内部，外界无法直接操作和修改。对一个类或对象实现良好的封装，可以实现以下目的：")]),t._v(" "),s("ul",[s("li",[t._v("隐藏类的实现细节；")]),t._v(" "),s("li",[t._v("让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问；")]),t._v(" "),s("li",[t._v("可进行数据检查，从而有利于保证对象信息的完整性；")]),t._v(" "),s("li",[t._v("便于修改，提高代码的可维护性。")])]),t._v(" "),s("p",[s("strong",[t._v("扩展阅读")])]),t._v(" "),s("p",[t._v("为了实现良好的封装，需要从两个方面考虑：")]),t._v(" "),s("ul",[s("li",[t._v("将对象的成员变量和实现细节隐藏起来，不允许外部直接访问；")]),t._v(" "),s("li",[t._v("把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。")])]),t._v(" "),s("p",[t._v("封装实际上有两个方面的含义："),s("strong",[t._v("把该隐藏的隐藏起来，把该暴露的暴露出来")]),t._v("。这两个方面都需要通过使用Java提供的访问控制符来实现。")]),t._v(" "),s("h4",{attrs:{id:"_1-15-说一说你对多态的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-15-说一说你对多态的理解"}},[t._v("#")]),t._v(" 1.15 说一说你对多态的理解")]),t._v(" "),s("p",[s("strong",[t._v("参考答案")])]),t._v(" "),s("p",[t._v("因为子类其实是一种特殊的父类，因此Java允许把一个子类对象直接赋给一个父类引用变量，无须任何类型转换，或者被称为"),s("strong",[t._v("向上转型")]),t._v("，向上转型由系统自动完成。")]),t._v(" "),s("p",[t._v("当把一个子类对象直接赋给父类引用变量时，例如 "),s("code",[t._v("BaseClass obj = new SubClass();")]),t._v("，这个obj引用变量的编译时类型是BaseClass，而运行时类型是SubClass，当运行时调用该引用变量的方法时，其方法行为总是"),s("strong",[t._v("表现出子类方法的行为特征")]),t._v("，而不是父类方法的行为特征，这就可能出现："),s("strong",[t._v("相同类型的变量、调用同一个方法时呈现出多种不同的行为特征")]),t._v("，这就是多态。")]),t._v(" "),s("p",[s("strong",[t._v("扩展阅读")])]),t._v(" "),s("p",[t._v("多态可以"),s("strong",[t._v("提高程序的可扩展性")]),t._v("，在设计程序时让代码更加简洁而优雅。")]),t._v(" "),s("p",[t._v("例如我要设计一个司机类，他可以开轿车、巴士、卡车等等，示例代码如下：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Driver")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("drive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Car")]),t._v(" car"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("drive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Bus")]),t._v(" bus"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("drive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Truck")]),t._v(" truck"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("p",[t._v("在设计上述代码时，我已采用了==重载机制==，将方法名进行了统一。这样在进行调用时，无论要开什么交通工具，都是通过 "),s("code",[t._v("driver.drive(obj)")]),t._v(" 这样的方式来调用，对调用者足够的友好。")]),t._v(" "),s("p",[t._v("但对于程序的开发者来说，这显得"),s("strong",[t._v("繁琐")]),t._v("，因为实际上这个司机可以驾驶更多的交通工具。当系统需要为这个司机增加车型时，开发者就需要相应的增加driver方法，"),s("strong",[t._v("类似的代码会堆积的越来越多，显得臃肿")]),t._v("。")]),t._v(" "),s("p",[t._v("采用多态的方式来设计上述程序，就会变得简洁很多。我们可以为所有的交通工具"),s("strong",[t._v("定义一个父类Vehicle")]),t._v("，然后按照如下的方式设计drive方法。调用时，我们可以传入Vehicle类型的实例，也可以传入任意的Vechile子类型的实例，对于调用者来说一样的方便，但对于开发者来说，代码却变得十分的简洁了。")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Driver")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("drive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Vehicle")]),t._v(" vehicle"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br")])])])}),[],!1,null,null,null);s.default=v.exports}}]);