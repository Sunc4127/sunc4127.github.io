(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{436:function(_,v,t){"use strict";t.r(v);var r=t(3),i=Object(r.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("nav",{staticClass:"table-of-contents"},[v("ol",[v("li",[v("a",{attrs:{href:"#1.16-java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"}},[_._v(" 1.16 Java中的多态是怎么实现的？")])]),v("li",[v("a",{attrs:{href:"#1.17-java%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"}},[_._v(" 1.17 Java为什么是单继承，为什么不能多继承？")])]),v("li",[v("a",{attrs:{href:"#1.18-%E8%AF%B4%E4%B8%80%E8%AF%B4%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB"}},[_._v(" 1.18 说一说重写与重载的区别")])]),v("li",[v("a",{attrs:{href:"#1.19-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E8%83%BD%E4%B8%8D%E8%83%BD%E9%87%8D%E5%86%99%EF%BC%9F"}},[_._v(" 1.19 构造方法能不能重写？")])]),v("li",[v("a",{attrs:{href:"#1.20-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bobject%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"}},[_._v(" 1.20 介绍一下Object类中的方法")])]),v("li",[v("a",{attrs:{href:"#1.21-%E8%AF%B4%E4%B8%80%E8%AF%B4hashcode()%E5%92%8Cequals()%E7%9A%84%E5%85%B3%E7%B3%BB"}},[_._v(" 1.21 说一说hashCode()和equals()的关系")])]),v("li",[v("a",{attrs:{href:"#1.22-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%87%8D%E5%86%99hashcode()%E5%92%8Cequals()%EF%BC%9F"}},[_._v(" 1.22 为什么要重写hashCode()和equals()？")])]),v("li",[v("a",{attrs:{href:"#1.23-%3D%3D%E5%92%8Cequals()%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"}},[_._v(" 1.23 ==和equals()有什么区别？")])]),v("li",[v("a",{attrs:{href:"#1.24-string%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9F"}},[_._v(" 1.24 String类有哪些方法？")])]),v("li",[v("a",{attrs:{href:"#1.25-string%E5%8F%AF%E4%BB%A5%E8%A2%AB%E7%BB%A7%E6%89%BF%E5%90%97%EF%BC%9F"}},[_._v(" 1.25 String可以被继承吗？")])]),v("li",[v("a",{attrs:{href:"#1.26-%E8%AF%B4%E4%B8%80%E8%AF%B4string%E5%92%8Cstringbuffer%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"}},[_._v(" 1.26 说一说String和StringBuffer有什么区别")])]),v("li",[v("a",{attrs:{href:"#1.27-%E8%AF%B4%E4%B8%80%E8%AF%B4stringbuffer%E5%92%8Cstringbuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"}},[_._v(" 1.27 说一说StringBuffer和StringBuilder有什么区别")])]),v("li",[v("a",{attrs:{href:"#1.28-%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%EF%BC%8Cnew%E5%92%8C%22%22%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"}},[_._v(' 1.28 使用字符串时，new和""推荐使用哪种方式？')])]),v("li",[v("a",{attrs:{href:"#1.29-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E7%9A%84%E7%90%86%E8%A7%A3"}},[_._v(" 1.29 说一说你对字符串拼接的理解")])]),v("li",[v("a",{attrs:{href:"#1.30-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"}},[_._v(" 1.30 两个字符串相加的底层是如何实现的？")])]),v("li",[v("a",{attrs:{href:"#1.31-string-a-%3D-%22abc%22%3B-%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E8%BF%87%E7%A8%8B%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"}},[_._v(' 1.31 String a = "abc"; ，说一下这个过程会创建什么，放在哪里？')])]),v("li",[v("a",{attrs:{href:"#1.32-new-string(%22abc%22)-%E6%98%AF%E5%8E%BB%E4%BA%86%E5%93%AA%E9%87%8C%EF%BC%8C%E4%BB%85%E4%BB%85%E6%98%AF%E5%9C%A8%E5%A0%86%E9%87%8C%E9%9D%A2%E5%90%97%EF%BC%9F"}},[_._v(' 1.32 new String("abc") 是去了哪里，仅仅是在堆里面吗？')])]),v("li",[v("a",{attrs:{href:"#1.33-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"}},[_._v(" 1.33 接口和抽象类有什么区别？")])]),v("li",[v("a",{attrs:{href:"#1.34-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97%EF%BC%9F"}},[_._v(" 1.34 接口中可以有构造函数吗？")])]),v("li",[v("a",{attrs:{href:"#1.35-%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3"}},[_._v(" 1.35 谈谈你对面向接口编程的理解")])])])]),v("h4",{attrs:{id:"_1-16-java中的多态是怎么实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-16-java中的多态是怎么实现的"}},[_._v("#")]),_._v(" 1.16 Java中的多态是怎么实现的？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("多态的实现离不开继承")]),_._v("，在设计程序时，我们可以将参数的类型定义为"),v("strong",[_._v("父类型")]),_._v("。")]),_._v(" "),v("li",[_._v("在调用程序时，则可以根据实际情况，"),v("strong",[_._v("传入该父类型的某个子类型的实例")]),_._v("，这样就实现了多态。")]),_._v(" "),v("li",[_._v("对于"),v("strong",[_._v("父类型")]),_._v("，可以有三种形式，即：\n"),v("ul",[v("li",[_._v("普通的类")]),_._v(" "),v("li",[_._v("抽象类")]),_._v(" "),v("li",[_._v("接口")])])]),_._v(" "),v("li",[_._v("对于"),v("strong",[_._v("子类型")]),_._v("，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法。")])]),_._v(" "),v("h4",{attrs:{id:"_1-17-java为什么是单继承-为什么不能多继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-17-java为什么是单继承-为什么不能多继承"}},[_._v("#")]),_._v(" 1.17 Java为什么是单继承，为什么不能多继承？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("首先，Java是单继承的，指的是"),v("strong",[_._v("Java中一个类只能有一个直接的父类")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("Java不能多继承，则是说"),v("strong",[_._v("Java中一个类不能直接继承多个父类")]),_._v("。")])]),_._v(" "),v("li",[v("p",[_._v("其次，Java在设计时借鉴了C++的语法，而C++是支持多继承的。")])]),_._v(" "),v("li",[v("p",[_._v("Java语言之所以摒弃了多继承的这项特征，是"),v("strong",[_._v("因为多继承容易产生混淆")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("比如，两个父类中包含相同的方法时，子类在调用该方法或重写该方法时就会迷惑。")])])]),_._v(" "),v("li",[v("p",[_._v('准确来说，Java是**可以实现"多继承"**的。因为尽管一个类只能有一个直接父类，但是却可以有任意多个间接的父类。这样的设计方式，避免了多继承时所产生的混淆。')])])]),_._v(" "),v("h4",{attrs:{id:"_1-18-说一说重写与重载的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-18-说一说重写与重载的区别"}},[_._v("#")]),_._v(" 1.18 说一说重写与重载的区别")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[v("mark",[_._v("重载")])]),_._v(" "),v("ul",[v("li",[_._v("发生在同一个类中，若多个方法之间"),v("strong",[_._v("方法名相同、参数列表不同")]),_._v("，则它们构成重载的关系。")]),_._v(" "),v("li",[_._v("重载与方法的返回值以及访问修饰符无关，即重载的方法不能根据返回类型进行区分。")])]),_._v(" "),v("p",[v("mark",[_._v("重写")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("发生在父类子类中")]),_._v("，若子类方法想要和父类方法构成重写关系，则它的方法名、参数列表必须与父类方法相同。")]),_._v(" "),v("li",[_._v("另外，返回值要"),v("strong",[_._v("小于等于")]),_._v("父类方法，抛出的异常要"),v("strong",[_._v("小于等于")]),_._v("父类方法，访问修饰符则要"),v("strong",[_._v("大于等于")]),_._v("父类方法。")]),_._v(" "),v("li",[_._v("还有，若父类方法的访问修饰符为private，则子类不能对其重写。")])]),_._v(" "),v("h4",{attrs:{id:"_1-19-构造方法能不能重写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-19-构造方法能不能重写"}},[_._v("#")]),_._v(" 1.19 构造方法能不能重写？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[_._v("构造方法"),v("strong",[_._v("不能重写")]),_._v("。")]),_._v(" "),v("li",[_._v("因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。")]),_._v(" "),v("li",[_._v("如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。")])]),_._v(" "),v("h4",{attrs:{id:"_1-20-介绍一下object类中的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-20-介绍一下object类中的方法"}},[_._v("#")]),_._v(" 1.20 介绍一下Object类中的方法")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[_._v("Object类提供了如下几个常用方法：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Class<?> getClass()：返回该对象的运行时类。")])]),_._v(" "),v("li",[v("p",[_._v("boolean equals(Object obj)：判断指定对象与该对象是否相等。")])]),_._v(" "),v("li",[v("p",[_._v("int hashCode()：返回该对象的hashCode值。在默认情况下，Object类的hashCode()方法根据该对象的"),v("strong",[_._v("地址")]),_._v("来计算。但很多类都重写了Object类的hashCode()方法，不再根据地址来计算其hashCode()方法值。")])]),_._v(" "),v("li",[v("p",[_._v("String toString()：返回该对象的字符串表示，当程序使用System.out.println()方法输出一个对象，或者把某个对象和字符串进行连接运算时，系统会自动调用该对象的toString()方法返回该对象的字符串表示。Object类的toString()方法返回 "),v("code",[_._v("运行时类名@十六进制hashCode值")]),_._v(" 格式的字符串，但很多类都重写了Object类的toString()方法，用于返回可以表述该对象信息的字符串。")])]),_._v(" "),v("li",[v("p",[_._v("另外，Object类还提供了")]),_._v(" "),v("ul",[v("li",[_._v("wait()")]),_._v(" "),v("li",[_._v("notify()")]),_._v(" "),v("li",[_._v("notifyAll()这几个方法")]),_._v(" "),v("li",[_._v("通过这几个方法可以"),v("strong",[_._v("控制线程")]),_._v("的暂停和运行。")])])]),_._v(" "),v("li",[v("p",[_._v("Object类还提供了一个clone()方法，该方法用于帮助其他对象来实现“"),v("mark",[_._v("自我克隆")]),_._v("”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。")])])]),_._v(" "),v("p",[v("strong",[_._v("扩展阅读")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Object类还提供了一个finalize()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来"),v("strong",[_._v("清理该对象的资源")]),_._v("。并且，针对某一个对象，垃圾回收器最多只会调用它的finalize()方法一次。")])]),_._v(" "),v("li",[v("p",[_._v("注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。")])]),_._v(" "),v("li",[v("p",[_._v("从JDK9开始，这个方法被标记为不推荐使用的方法。")])])]),_._v(" "),v("h4",{attrs:{id:"_1-21-说一说hashcode-和equals-的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-21-说一说hashcode-和equals-的关系"}},[_._v("#")]),_._v(" 1.21 说一说hashCode()和equals()的关系")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[_._v("==hashCode()==用于获取哈希码（散列码），==eauqls()==用于比较两个对象是否相等，它们应遵守如下规定：")]),_._v(" "),v("ul",[v("li",[_._v("如果两个对象相等，则它们必须有相同的哈希码。")]),_._v(" "),v("li",[_._v("如果两个对象有相同的哈希码，则它们未必相等。")])]),_._v(" "),v("p",[v("strong",[_._v("扩展阅读")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("在Java中，"),v("strong",[_._v("Set")]),_._v("接口代表无序的、元素不可重复的集合，HashSet则是Set接口的典型实现。")])]),_._v(" "),v("li",[v("p",[_._v("当向HashSet中加入一个元素时，它需要判断集合中是否已经包含了这个元素，从而避免重复存储。")]),_._v(" "),v("ul",[v("li",[_._v("由于这个判断十分的频繁，所以要讲求效率，绝不能采用遍历集合逐个元素进行比较的方式。")]),_._v(" "),v("li",[_._v("实际上，HashSet是通过获取对象的"),v("strong",[_._v("哈希码")]),_._v("，以及调用对象的equals()方法来解决这个判断问题的。")])])]),_._v(" "),v("li",[v("p",[_._v("HashSet首先会调用对象的hashCode()方法获取其哈希码，并"),v("strong",[_._v("通过哈希码确定该对象在集合中存放的位置")]),_._v("。假设这个位置之前已经存了一个对象，则HashSet会调用**equals()**对两个对象进行比较。")]),_._v(" "),v("ul",[v("li",[_._v("若相等则说明对象重复，此时不会保存新加的对象。")]),_._v(" "),v("li",[_._v("若不等说明对象不重复，但是它们存储的位置发生了碰撞，此时HashSet会"),v("strong",[_._v("采用链式结构")]),_._v("在同一位置保存多个对象，即将新加对象链接到原来对象的之后。之后，再有新添加对象也映射到这个位置时，就需要与这个位置中所有的对象进行equals()比较，若均不相等则将其链到最后一个对象之后。")])])])]),_._v(" "),v("h4",{attrs:{id:"_1-22-为什么要重写hashcode-和equals"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-22-为什么要重写hashcode-和equals"}},[_._v("#")]),_._v(" 1.22 为什么要重写hashCode()和equals()？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Object类提供的equals()方法默认是用"),v("code",[_._v("==")]),_._v("来进行比较的，也就是说只有两个对象是"),v("strong",[_._v("同一个对象")]),_._v("时，才能返回相等的结果。")])]),_._v(" "),v("li",[v("p",[_._v("而实际的业务中，我们通常的需求是，若两个不同的对象它们的"),v("strong",[_._v("内容是相同")]),_._v("的，"),v("strong",[_._v("就认为它们相等")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("鉴于这种情况，Object类中equals()方法的默认实现是"),v("strong",[_._v("没有实用价值")]),_._v("的，所以"),v("strong",[_._v("通常都要重写")]),_._v("。")])])]),_._v(" "),v("li",[v("p",[_._v("由于hashCode()与equals()具有联动关系（参考“说一说hashCode()和equals()的关系”一题），所以equals()方法重写时，通常也要将hashCode()进行重写，使得这两个方法"),v("strong",[_._v("始终满足相关的约定")]),_._v("。")])])]),_._v(" "),v("h4",{attrs:{id:"_1-23-和equals-有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-23-和equals-有什么区别"}},[_._v("#")]),_._v(" 1.23 ==和equals()有什么区别？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[_._v("=="),v("mark",[_._v("运算符")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("作用于"),v("strong",[_._v("基本数据类型")]),_._v("时，是比较两个"),v("strong",[_._v("数值是否相等")]),_._v("；")]),_._v(" "),v("li",[_._v("作用于"),v("strong",[_._v("引用数据类型")]),_._v("时，是比较两个对象的"),v("strong",[_._v("内存地址是否相同")]),_._v("，即判断它们是否为同一个对象；")])]),_._v(" "),v("p",[v("mark",[_._v("equals()方法")]),_._v("：")]),_._v(" "),v("ul",[v("li",[_._v("没有重写时，Object默认以 "),v("code",[_._v("==")]),_._v(" 来实现，即比较两个对象的"),v("strong",[_._v("内存地址是否相同")]),_._v("；")]),_._v(" "),v("li",[_._v("进行重写后，一般会"),v("strong",[_._v("按照对象的内容来进行比较")]),_._v("，若两个对象内容相同则认为对象相等，否则认为对象不等。")])]),_._v(" "),v("h4",{attrs:{id:"_1-24-string类有哪些方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-24-string类有哪些方法"}},[_._v("#")]),_._v(" 1.24 String类有哪些方法？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[_._v("String类是Java最常用的API，它包含了大量处理字符串的方法，比较常用的有：")]),_._v(" "),v("ul",[v("li",[_._v("char charAt(int index)：返回指定索引处的字符；")]),_._v(" "),v("li",[_._v("String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；")]),_._v(" "),v("li",[_._v("String[] split(String regex)：以指定的规则将此字符串分割成数组；")]),_._v(" "),v("li",[_._v("String trim()：删除字符串前导和后置的空格；")]),_._v(" "),v("li",[_._v("int indexOf(String str)：返回子串在此字符串首次出现的索引；")]),_._v(" "),v("li",[_._v("int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；")]),_._v(" "),v("li",[_._v("boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；")]),_._v(" "),v("li",[_._v("boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；")]),_._v(" "),v("li",[_._v("String toUpperCase()：将此字符串中所有的字符大写；")]),_._v(" "),v("li",[_._v("String toLowerCase()：将此字符串中所有的字符小写；")]),_._v(" "),v("li",[_._v("String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；")]),_._v(" "),v("li",[_._v("String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。")])]),_._v(" "),v("p",[v("strong",[_._v("注意事项")])]),_._v(" "),v("p",[_._v("String类的方法太多了，你没必要都记下来，更不需要一一列举。面试时能说出一些常用的方法，表现出对这个类足够的熟悉就可以了。另外，建议你挑几个方法仔细看看源码实现，面试时可以重点说这几个方法。")]),_._v(" "),v("h4",{attrs:{id:"_1-25-string可以被继承吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-25-string可以被继承吗"}},[_._v("#")]),_._v(" 1.25 String可以被继承吗？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[_._v("String类"),v("strong",[_._v("由final修饰，所以不能被继承")]),_._v("。")])]),_._v(" "),v("p",[v("strong",[_._v("扩展阅读")])]),_._v(" "),v("p",[_._v("在Java中，String类被设计为不可变类，主要表现在它保存字符串的成员变量是final的。")]),_._v(" "),v("ul",[v("li",[_._v("Java 9之前字符串采用char[]数组来保存字符，即 "),v("code",[_._v("private final char[] value")]),_._v("；")]),_._v(" "),v("li",[_._v("Java 9做了改进，采用byte[]数组来保存字符，即 "),v("code",[_._v("private final byte[] value")]),_._v("；")])]),_._v(" "),v("p",[_._v("之所以要把String类设计为不可变类，主要是"),v("strong",[_._v("出于安全和性能的考虑")]),_._v("，可归纳为如下4点。")]),_._v(" "),v("ul",[v("li",[_._v("由于字符串无论在任何 Java 系统中都广泛使用，会用来"),v("strong",[_._v("存储敏感信息")]),_._v("，如账号，密码，网络路径，文件处理等场景里，保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。")]),_._v(" "),v("li",[_._v("在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。"),v("strong",[_._v("由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用")]),_._v("，访问的都是同样的字符串数据，不需要任何同步操作。")]),_._v(" "),v("li",[_._v("字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 "),v("code",[_._v("hashCode()")]),_._v(" 方法来确定元素的位置。由于字符串 "),v("code",[_._v("hashcode")]),_._v(" 属性不会变更，"),v("strong",[_._v("保证了唯一性")]),_._v("，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，"),v("strong",[_._v("避免重复计算 "),v("code",[_._v("hashcode")])]),_._v("，只要使用缓存的 "),v("code",[_._v("hashcode")]),_._v(" 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。")]),_._v(" "),v("li",[_._v("当字符串不可变时，==字符串常量池==才有意义。"),v("strong",[_._v("字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存")]),_._v("。若字符串可变，字符串常量池失去意义，基于常量池的 "),v("code",[_._v("String.intern()")]),_._v(" 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。")])]),_._v(" "),v("p",[_._v("因为要保证String类的不可变，那么将这个类定义为final的就很容易理解了。"),v("strong",[_._v("如果没有final修饰，那么就会存在String的子类，这些子类可以重写String类的方法，强行改变字符串的值，这便违背了String类设计的初衷")]),_._v("。")]),_._v(" "),v("h4",{attrs:{id:"_1-26-说一说string和stringbuffer有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-26-说一说string和stringbuffer有什么区别"}},[_._v("#")]),_._v(" 1.26 说一说String和StringBuffer有什么区别")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("==String==类是"),v("strong",[_._v("不可变类")]),_._v("，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。")])]),_._v(" "),v("li",[v("p",[_._v("==StringBuffer==对象则代表一个字符序列"),v("strong",[_._v("可变的字符串")]),_._v("，当一个StringBuffer被创建以后，通过StringBuffer提供的")]),_._v(" "),v("ul",[v("li",[_._v("append()")]),_._v(" "),v("li",[_._v("insert()")]),_._v(" "),v("li",[_._v("reverse()")]),_._v(" "),v("li",[_._v("setCharAt()")]),_._v(" "),v("li",[_._v("setLength()")]),_._v(" "),v("li",[_._v("等方法可以改变这个字符串对象的字符序列。")]),_._v(" "),v("li",[_._v("一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。")])])])]),_._v(" "),v("h4",{attrs:{id:"_1-27-说一说stringbuffer和stringbuilder有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-27-说一说stringbuffer和stringbuilder有什么区别"}},[_._v("#")]),_._v(" 1.27 说一说StringBuffer和StringBuilder有什么区别")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("StringBuffer、StringBuilder"),v("strong",[_._v("都代表可变的字符串对象")]),_._v("，它们有共同的父类 "),v("code",[_._v("AbstractStringBuilder")]),_._v("，并且两个类的构造方法和成员方法也基本相同。")])]),_._v(" "),v("li",[v("p",[_._v("不同的是，"),v("strong",[_._v("StringBuffer是线程安全的，而StringBuilder是非线程安全的")]),_._v("，所以"),v("strong",[_._v("StringBuilder性能略高")]),_._v("。一般情况下，要创建一个内容可变的字符串，建议"),v("strong",[_._v("优先考虑StringBuilder类")]),_._v("。")])])]),_._v(" "),v("h4",{attrs:{id:"_1-28-使用字符串时-new和-推荐使用哪种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-28-使用字符串时-new和-推荐使用哪种方式"}},[_._v("#")]),_._v(' 1.28 使用字符串时，new和""推荐使用哪种方式？')]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[_._v("先看看 "),v("code",[_._v('"hello"')]),_._v(" 和 "),v("code",[_._v('new String("hello")')]),_._v(" 的区别：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("当Java程序直接使用 "),v("code",[_._v('"hello"')]),_._v(" 的字符串"),v("strong",[_._v("直接量")]),_._v("时，JVM将会使用"),v("strong",[_._v("常量池")]),_._v("来管理这个字符串；")])]),_._v(" "),v("li",[v("p",[_._v("当使用 "),v("code",[_._v('new String("hello")')]),_._v(" 时，JVM会先使用"),v("strong",[_._v("常量池")]),_._v("来管理 "),v("code",[_._v('"hello"')]),_._v(" "),v("strong",[_._v("直接量")]),_._v("，再调用String类的构造器来"),v("strong",[_._v("创建一个新的String对象")]),_._v("，新创建的String对象被保存在堆内存中。")])]),_._v(" "),v("li",[v("p",[_._v("显然，采用new的方式会"),v("strong",[_._v("多创建一个对象出来")]),_._v("，会"),v("strong",[_._v("占用更多的内存")]),_._v("，所以"),v("strong",[_._v("一般建议使用直接量的方式创建字符串")]),_._v("。")])])]),_._v(" "),v("h4",{attrs:{id:"_1-29-说一说你对字符串拼接的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-29-说一说你对字符串拼接的理解"}},[_._v("#")]),_._v(" 1.29 说一说你对字符串拼接的理解")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[_._v("拼接字符串有很多种方式，其中最常用的有4种，下面列举了这4种方式各自适合的场景。")]),_._v(" "),v("ol",[v("li",[v("code",[_._v("+")]),_._v(" 运算符：如果拼接的都是字符串直接量，则适合使用 "),v("code",[_._v("+")]),_._v(" 运算符实现拼接；")]),_._v(" "),v("li",[_._v("StringBuilder：如果拼接的字符串中"),v("strong",[_._v("包含变量")]),_._v("，并不要求线程安全，则适合使用StringBuilder；")]),_._v(" "),v("li",[_._v("StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；")]),_._v(" "),v("li",[_._v("String类的concat方法：如果只是对"),v("strong",[_._v("两个")]),_._v("字符串进行拼接，并且包含变量，则适合使用concat方法；")])]),_._v(" "),v("p",[v("strong",[_._v("扩展阅读")])]),_._v(" "),v("p",[_._v("采用 "),v("code",[_._v("+")]),_._v(" 运算符拼接字符串时：")]),_._v(" "),v("ul",[v("li",[_._v("如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的，所以"),v("strong",[_._v("效率非常的高")]),_._v("。")]),_._v(" "),v("li",[_._v("如果拼接的字符串中"),v("strong",[_._v("包含变量")]),_._v("，则在编译时"),v("strong",[_._v("编译器采用StringBuilder对其进行优化")]),_._v("，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起，效率也很高。"),v("strong",[_._v("但")]),_._v("如果这个拼接操作是在循环中进行的，那么每次循环编译器都会创建一个StringBuilder实例，再去拼接字符串，相当于执行了 "),v("code",[_._v("new StringBuilder().append(str)")]),_._v("，所以此时效率很低。")])]),_._v(" "),v("p",[_._v("采用StringBuilder/StringBuffer拼接字符串时：")]),_._v(" "),v("ul",[v("li",[_._v("StringBuilder/StringBuffer都有==字符串缓冲区==，缓冲区的容量在创建对象时确定，并且默认为16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。")]),_._v(" "),v("li",[v("strong",[_._v("缓冲区频繁的扩容会降低拼接的性能")]),_._v("，所以如果能提前预估最终字符串的长度，则建议在创建可变字符串对象时，放弃使用默认的容量，可以指定缓冲区的容量为预估的字符串的长度。")])]),_._v(" "),v("p",[_._v("采用String类的concat方法拼接字符串时：")]),_._v(" "),v("ul",[v("li",[_._v("concat方法的拼接逻辑是，先创建一个足以容纳待拼接的两个字符串的"),v("strong",[_._v("字节数组")]),_._v("，然后先后将两个字符串拼到这个数组里，最后"),v("strong",[_._v("将此数组转换为字符串")]),_._v("。")]),_._v(" "),v("li",[_._v("在拼接大量字符串的时候，concat方法的效率低于StringBuilder。但是"),v("strong",[_._v("只拼接2个字符串时，concat方法的效率要优于StringBuilder")]),_._v("。并且这种拼接方式"),v("strong",[_._v("代码简洁")]),_._v("，所以只拼2个字符串时建议优先选择concat方法。")])]),_._v(" "),v("h4",{attrs:{id:"_1-30-两个字符串相加的底层是如何实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-30-两个字符串相加的底层是如何实现的"}},[_._v("#")]),_._v(" 1.30 两个字符串相加的底层是如何实现的？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("如果拼接的都是字符串"),v("strong",[_._v("直接量")]),_._v("，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的。")])]),_._v(" "),v("li",[v("p",[_._v("如果拼接的字符串中"),v("strong",[_._v("包含变量")]),_._v("，则在编译时编译器"),v("strong",[_._v("采用StringBuilder对其进行优化")]),_._v("，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起。")])])]),_._v(" "),v("h4",{attrs:{id:"_1-31-string-a-abc-说一下这个过程会创建什么-放在哪里"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-31-string-a-abc-说一下这个过程会创建什么-放在哪里"}},[_._v("#")]),_._v(" 1.31 "),v("code",[_._v('String a = "abc";')]),_._v(" ，说一下这个过程会创建什么，放在哪里？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[_._v("JVM会使用"),v("strong",[_._v("常量池")]),_._v("来管理字符串"),v("strong",[_._v("直接量")]),_._v('。在执行这句话时，JVM会先检查常量池中是否已经存有"abc"，\n'),v("ul",[v("li",[_._v('若没有则将"abc"存入常量池，')]),_._v(" "),v("li",[_._v("否则就"),v("strong",[_._v("复用")]),_._v('常量池中已有的"abc"，将其引用赋值给变量a。')])])])]),_._v(" "),v("h4",{attrs:{id:"_1-32-new-string-abc-是去了哪里-仅仅是在堆里面吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-32-new-string-abc-是去了哪里-仅仅是在堆里面吗"}},[_._v("#")]),_._v(" 1.32 "),v("code",[_._v('new String("abc")')]),_._v(" 是去了哪里，仅仅是在堆里面吗？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[_._v("在执行这句话时，JVM会"),v("strong",[_._v("先使用常量池")]),_._v('来管理字符串直接量，即将"abc"存入常量池。')]),_._v(" "),v("li",[_._v("然后"),v("strong",[_._v("再创建一个新的String对象")]),_._v("，这个对象会被"),v("strong",[_._v("保存在堆内存中")]),_._v("。")]),_._v(" "),v("li",[_._v("并且，堆中对象的数据会指向常量池中的直接量。")])]),_._v(" "),v("h4",{attrs:{id:"_1-33-接口和抽象类有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-33-接口和抽象类有什么区别"}},[_._v("#")]),_._v(" 1.33 接口和抽象类有什么区别？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("p",[_._v("从设计目的上来说，二者有如下的区别：")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("==接口==体现的是一种"),v("strong",[_._v("规范")]),_._v("。")]),_._v(" "),v("ul",[v("li",[_._v("对于接口的实现者而言，接口规定了实现者必须向外提供哪些服务；")]),_._v(" "),v("li",[_._v("对于接口的调用者而言，接口规定了调用者可以调用哪些服务，以及如何调用这些服务。")]),_._v(" "),v("li",[_._v("当在一个程序中使用接口时，接口是多个模块间的"),v("strong",[_._v("耦合标准")]),_._v("；")]),_._v(" "),v("li",[_._v("当在多个应用程序之间使用接口时，接口是多个程序之间的"),v("strong",[_._v("通信标准")]),_._v("。")])])]),_._v(" "),v("li",[v("p",[_._v("==抽象类==体现的是一种模板式设计。")]),_._v(" "),v("ul",[v("li",[_._v("抽象类作为多个子类的抽象父类，可以被当成系统实现过程中的中间产品，这个中间产品已经实现了系统的部分功能，但这个产品依然不能当成最终产品，必须有更进一步的完善，这种完善可能有几种不同方式。")])])])]),_._v(" "),v("p",[_._v("从使用方式上来说，二者有如下的区别：")]),_._v(" "),v("ul",[v("li",[_._v("接口里只能包含抽象方法、静态方法、默认方法和私有方法，不能为普通方法提供方法实现；\n"),v("ul",[v("li",[_._v("抽象类则完全可以包含普通方法。")])])]),_._v(" "),v("li",[_._v("接口里只能定义静态常量，不能定义普通成员变量；\n"),v("ul",[v("li",[_._v("抽象类里则既可以定义普通成员变量，也可以定义静态常量。")])])]),_._v(" "),v("li",[_._v("接口里不包含构造器；\n"),v("ul",[v("li",[_._v("抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。")])])]),_._v(" "),v("li",[_._v("接口里不能包含初始化块；\n"),v("ul",[v("li",[_._v("但抽象类则完全可以包含初始化块。")])])]),_._v(" "),v("li",[_._v("一个类最多只能有一个直接父类，包括抽象类；\n"),v("ul",[v("li",[_._v("但一个类可以直接实现多个接口，通过实现多个接口可以弥补Java单继承的不足。")])])])]),_._v(" "),v("p",[v("strong",[_._v("扩展阅读")])]),_._v(" "),v("p",[_._v("接口和抽象类很像，它们都具有如下共同的特征：")]),_._v(" "),v("ul",[v("li",[_._v("接口和抽象类"),v("strong",[_._v("都不能被实例化")]),_._v("，它们都位于继承树的顶端，用于被其他类实现和继承。")]),_._v(" "),v("li",[_._v("接口和抽象类"),v("strong",[_._v("都可以包含抽象方法")]),_._v("，实现接口或继承抽象类的普通子类都必须实现这些抽象方法。")])]),_._v(" "),v("h4",{attrs:{id:"_1-34-接口中可以有构造函数吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-34-接口中可以有构造函数吗"}},[_._v("#")]),_._v(" 1.34 接口中可以有构造函数吗？")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[_._v("由于接口定义的是一种规范，因此接口里不能包含：\n"),v("ul",[v("li",[_._v("构造器")]),_._v(" "),v("li",[_._v("初始化块定义。")])])]),_._v(" "),v("li",[_._v("接口里可以包含：\n"),v("ul",[v("li",[_._v("成员变量（只能是静态常量）")]),_._v(" "),v("li",[_._v("方法（只能是抽象实例方法、类方法、默认方法或私有方法）")]),_._v(" "),v("li",[_._v("内部类（包括内部接口、枚举）定义。")])])])]),_._v(" "),v("h4",{attrs:{id:"_1-35-谈谈你对面向接口编程的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-35-谈谈你对面向接口编程的理解"}},[_._v("#")]),_._v(" 1.35 谈谈你对面向接口编程的理解")]),_._v(" "),v("p",[v("strong",[_._v("参考答案")])]),_._v(" "),v("ul",[v("li",[_._v("接口体现的是一种"),v("strong",[_._v("规范和实现分离的设计哲学")]),_._v("，充分利用接口可以极好地"),v("strong",[_._v("降低程序各模块之间的耦合")]),_._v("，从而"),v("strong",[_._v("提高系统的可扩展性和可维护性")]),_._v("。")]),_._v(" "),v("li",[_._v("基于这种原则，很多软件架构设计理论都倡导“面向接口”编程，而不是面向实现类编程，希望通过面向接口编程来降低程序的耦合。")])])])}),[],!1,null,null,null);v.default=i.exports}}]);