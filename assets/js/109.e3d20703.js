(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{433:function(t,v,_){"use strict";_.r(v);var a=_(3),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h4",{attrs:{id:"_1-36-遇到过异常吗-如何处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-36-遇到过异常吗-如何处理"}},[t._v("#")]),t._v(" 1.36 遇到过异常吗，如何处理？")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("在Java中，可以按照如下三个步骤处理异常：")]),t._v(" "),v("ol",[v("li",[t._v("捕获异常\n"),v("ul",[v("li",[t._v("将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。")]),t._v(" "),v("li",[t._v("创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。")])])]),t._v(" "),v("li",[t._v("处理异常\n"),v("ul",[v("li",[t._v("在catch块中处理异常时，应该先"),v("strong",[t._v("记录日志")]),t._v("，便于以后追溯这个异常。")]),t._v(" "),v("li",[t._v("然后根据异常的类型、结合当前的业务情况，进行相应的处理。")]),t._v(" "),v("li",[t._v("比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。")])])]),t._v(" "),v("li",[t._v("回收资源\n"),v("ul",[v("li",[t._v("如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。")]),t._v(" "),v("li",[t._v("并且，无论是否发生异常，都要"),v("strong",[t._v("尝试关闭这项资源")]),t._v("。"),v("strong",[t._v("将关闭资源的代码写在finally块内")]),t._v("，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。")])])])]),t._v(" "),v("h4",{attrs:{id:"_1-37-说一说java的异常机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-37-说一说java的异常机制"}},[t._v("#")]),t._v(" 1.37 说一说Java的异常机制")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("关于"),v("strong",[t._v("异常处理")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("在Java中，处理异常的语句由\n"),v("ul",[v("li",[t._v("try")]),t._v(" "),v("li",[t._v("catch")]),t._v(" "),v("li",[t._v("finally三部分组成。")])])]),t._v(" "),v("li",[t._v("其中，\n"),v("ul",[v("li",[t._v("try块用于包裹业务代码")]),t._v(" "),v("li",[t._v("catch块用于捕获并处理某个类型的异常")]),t._v(" "),v("li",[t._v("finally块则用于回收资源。")])])]),t._v(" "),v("li",[t._v("当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。")]),t._v(" "),v("li",[t._v("若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。")])]),t._v(" "),v("p",[t._v("关于"),v("strong",[t._v("抛出异常")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。")]),t._v(" "),v("li",[t._v("当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。")]),t._v(" "),v("li",[t._v("在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。")])]),t._v(" "),v("p",[t._v("关于"),v("strong",[t._v("异常跟踪栈")]),t._v("：")]),t._v(" "),v("ul",[v("li",[t._v("程序运行时，经常会发生一系列方法调用，从而形成==方法调用栈==。异常机制会导致"),v("strong",[t._v("异常在这些方法之间传播")]),t._v("，而异常传播的顺序与方法的调用相反。")]),t._v(" "),v("li",[t._v("异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，")]),t._v(" "),v("li",[t._v("以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息")])]),t._v(" "),v("h4",{attrs:{id:"_1-38-请介绍java的异常接口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-38-请介绍java的异常接口"}},[t._v("#")]),t._v(" 1.38 请介绍Java的异常接口")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("==Throwable==是异常的顶层父类，代表所有的非正常情况。它有两个直接子类，分别是Error、Exception。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("==Error==是"),v("strong",[t._v("错误")])]),t._v(" "),v("ul",[v("li",[t._v("一般是指与虚拟机相关的问题，如系统崩溃、虚拟机错误、动态链接失败等")]),t._v(" "),v("li",[t._v("这种错误无法恢复或不可能捕获，将导致应用程序中断")]),t._v(" "),v("li",[t._v("通常应用程序无法处理这些错误，因此应用程序不应该试图使用catch块来捕获Error对象")]),t._v(" "),v("li",[t._v("在定义方法时，也无须在其throws子句中声明该方法可能抛出Error及其任何子类")])])]),t._v(" "),v("li",[v("p",[t._v("==Exception==是"),v("strong",[t._v("异常")])]),t._v(" "),v("ul",[v("li",[t._v("它被分为两大类:\n"),v("ul",[v("li",[t._v("Checked异常")]),t._v(" "),v("li",[t._v("Runtime异常。")])])]),t._v(" "),v("li",[t._v("所有的RuntimeException类及其子类的实例被称为Runtime异常；不是RuntimeException类及其子类的异常实例则被称为Checked异常")]),t._v(" "),v("li",[t._v("Java认为Checked异常都是可以被处理（修复）的异常，所以Java程序必须显式处理Checked异常")]),t._v(" "),v("li",[t._v("如果程序没有处理Checked异常，该程序在编译时就会发生错误，无法通过编译。")]),t._v(" "),v("li",[t._v("Runtime异常则更加灵活，Runtime异常无须显式声明抛出，如果程序需要捕获Runtime异常，也可以使用try...catch块来实现。")])])])]),t._v(" "),v("h4",{attrs:{id:"_1-39-finally是无条件执行的吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-39-finally是无条件执行的吗"}},[t._v("#")]),t._v(" 1.39 finally是无条件执行的吗？")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。")]),t._v(" "),v("p",[v("strong",[t._v("注意事项")])]),t._v(" "),v("p",[t._v("如果在try块或catch块中使用 "),v("code",[t._v("System.exit(1);")]),t._v(" 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。")]),t._v(" "),v("h4",{attrs:{id:"_1-40-在finally中return会发生什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-40-在finally中return会发生什么"}},[t._v("#")]),t._v(" 1.40 在finally中return会发生什么？")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中的return、throw语句"),v("strong",[t._v("失效")]),t._v("。")]),t._v(" "),v("p",[v("strong",[t._v("详细解析")])]),t._v(" "),v("ul",[v("li",[t._v("当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束,")]),t._v(" "),v("li",[t._v("但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，")]),t._v(" "),v("li",[t._v("如果没有finally块，程序立即执行return或throw语句，方法终止；")]),t._v(" "),v("li",[t._v("如果有finally块，系统立即开始执行finally块。")]),t._v(" "),v("li",[t._v("只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句；")]),t._v(" "),v("li",[t._v("如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。")])]),t._v(" "),v("h4",{attrs:{id:"_1-41-说一说你对static关键字的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-41-说一说你对static关键字的理解"}},[t._v("#")]),t._v(" 1.41 说一说你对static关键字的理解")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("ul",[v("li",[v("p",[t._v("在Java类里只能包含成")]),t._v(" "),v("ul",[v("li",[t._v("员变量、")]),t._v(" "),v("li",[t._v("方法、")]),t._v(" "),v("li",[t._v("构造器、")]),t._v(" "),v("li",[t._v("初始化块、")]),t._v(" "),v("li",[t._v("内部类（包括接口、枚举）5种成员，")])])]),t._v(" "),v("li",[v("p",[t._v("而static可以修饰")]),t._v(" "),v("ul",[v("li",[t._v("成员变量、")]),t._v(" "),v("li",[t._v("方法、")]),t._v(" "),v("li",[t._v("初始化块、")]),t._v(" "),v("li",[t._v("内部类（包括接口、枚举），")])])]),t._v(" "),v("li",[v("p",[t._v("以static修饰的成员就是"),v("strong",[t._v("类成员")]),t._v("。"),v("strong",[t._v("类成员属于整个类，而不属于单个对象")]),t._v("。")])]),t._v(" "),v("li",[v("p",[t._v("对static关键字而言，有一条非常重要的规则：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("类成员")]),t._v("（包括成员变量、方法、初始化块、内部类和内部枚举）"),v("strong",[t._v("不能访问实例成员")]),t._v("（包括成员变量、方法、初始化块、内部类和内部枚举）。")]),t._v(" "),v("li",[t._v("因为类成员是属于类的，类成员的作用域比实例成员的作用域更大，完全可能出现类成员已经初始化完成，但实例成员还不曾初始化的情况，如果允许类成员访问实例成员将会引起大量错误。")])])])]),t._v(" "),v("h4",{attrs:{id:"_1-42-static修饰的类能不能被继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-42-static修饰的类能不能被继承"}},[t._v("#")]),t._v(" 1.42 static修饰的类能不能被继承？")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("static修饰的类可以被继承。")]),t._v(" "),v("p",[v("strong",[t._v("扩展阅读")])]),t._v(" "),v("p",[t._v("如果使用static来修饰一个内部类，则"),v("strong",[t._v("这个内部类就属于外部类本身，而不属于外部类的某个对象")]),t._v("。因此使用static修饰的内部类被称为类内部类，有的地方也称为==静态内部类==。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("static关键字的作用是把类的成员变成类相关，而不是实例相关，即static修饰的成员属于整个类，而不属于单个对象")]),t._v("。")]),t._v(" "),v("li",[t._v("外部类的上一级程序单元是包，所以不可使用static修饰；")]),t._v(" "),v("li",[t._v("而内部类的上一级程序单元是外部类，使用static修饰可以将内部类变成外部类相关，而不是外部类实例相关。")]),t._v(" "),v("li",[v("strong",[t._v("因此static关键字不可修饰外部类，但可修饰内部类")]),t._v("。")])]),t._v(" "),v("p",[t._v("静态内部类需满足如下规则：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("静态内部类可以包含静态成员，也可以包含非静态成员；")])]),t._v(" "),v("li",[v("p",[t._v("静态内部类不能访问外部类的实例成员，只能访问它的静态成员；")])]),t._v(" "),v("li",[v("p",[t._v("外部类的所有方法、初始化块都能访问其内部定义的静态内部类；")])]),t._v(" "),v("li",[v("p",[t._v("在外部类的外部，也可以实例化静态内部类，语法如下：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[t._v("外部类"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("内部类 变量名 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" 外部类"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("内部类构造方法"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])])])]),t._v(" "),v("h4",{attrs:{id:"_1-43-static和final有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-43-static和final有什么区别"}},[t._v("#")]),t._v(" 1.43 static和final有什么区别？")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("static关键字可以修饰成员变量、成员方法、初始化块、内部类，被static修饰的成员是类的成员，它属于类、不属于单个对象。以下是static修饰这4种成员时表现出的特征：")]),t._v(" "),v("ul",[v("li",[t._v("类变量：被static修饰的成员变量叫类变量（静态变量）。类变量属于类，它随类的信息存储在方法区，并不随对象存储在堆中，类变量可以通过类名来访问，也可以通过对象名来访问，但建议通过类名访问它。")]),t._v(" "),v("li",[t._v("类方法：被static修饰的成员方法叫类方法（静态方法）。类方法属于类，可以通过类名访问，也可以通过对象名访问，建议通过类名访问它。")]),t._v(" "),v("li",[t._v("静态块：被static修饰的初始化块叫静态初始化块。静态块属于类，它在类加载的时候被隐式调用一次，之后便不会被调用了。")]),t._v(" "),v("li",[t._v("静态内部类：被static修饰的内部类叫静态内部类。静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的静态成员。外部类的所有方法、初始化块都能访问其内部定义的静态内部类。")])]),t._v(" "),v("p",[t._v("final关键字可以修饰类、方法、变量，以下是final修饰这3种目标时表现出的特征：")]),t._v(" "),v("ul",[v("li",[t._v("final类：final关键字修饰的类不可以被继承。")]),t._v(" "),v("li",[t._v("final方法：final关键字修饰的方法不可以被重写。")]),t._v(" "),v("li",[t._v("final变量：final关键字修饰的变量，一旦获得了初始值，就不可以被修改。")])]),t._v(" "),v("p",[v("strong",[t._v("扩展阅读")])]),t._v(" "),v("p",[t._v("变量分为成员变量、局部变量。")]),t._v(" "),v("p",[t._v("final修饰成员变量：")]),t._v(" "),v("ul",[v("li",[t._v("类变量：可以在声明变量时指定初始值，也可以在静态初始化块中指定初始值；")]),t._v(" "),v("li",[t._v("实例变量：可以在声明变量时指定初始值，也可以在初始化块或构造方法中指定初始值；")])]),t._v(" "),v("p",[t._v("final修饰局部变量：")]),t._v(" "),v("ul",[v("li",[t._v("可以在声明变量时指定初始值，也可以在后面的代码中指定初始值。")])]),t._v(" "),v("p",[v("em",[t._v("注意：被 final 修饰的任何形式的变量，一旦获得了初始值，就不可以被修改！")])]),t._v(" "),v("h4",{attrs:{id:"_1-44-说一说你对泛型的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-44-说一说你对泛型的理解"}},[t._v("#")]),t._v(" 1.44 说一说你对泛型的理解")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("Java集合有个缺点—把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，当再次取出该对象时，该对象的编译类型就变成了Object类型（其运行时类型没变）。")]),t._v(" "),v("p",[t._v("Java集合之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：")]),t._v(" "),v("ul",[v("li",[t._v("集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存Dog对象的集合，但程序也可以轻易地将Cat对象“丢”进去，所以可能引发异常。")]),t._v(" "),v("li",[t._v("由于把对象“丢进”集合时，集合丢失了对象的状态信息，只知道它盛装的是Object，因此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，也可能引发ClassCastException异常。")])]),t._v(" "),v("p",[t._v("从Java 5开始，Java引入了“参数化类型”的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为泛型（Generic）。例如 "),v("code",[t._v("List<String>")]),t._v("，表明该List只能保存字符串类型的对象。")]),t._v(" "),v("p",[t._v("有了泛型以后，程序再也不能“不小心”地把其他对象“丢进”集合中。而且程序更加简洁，集合自动记住所有集合元素的数据类型，从而无须对集合元素进行强制类型转换。")]),t._v(" "),v("h4",{attrs:{id:"_1-45-介绍一下泛型擦除"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-45-介绍一下泛型擦除"}},[t._v("#")]),t._v(" 1.45 介绍一下泛型擦除")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("在严格的泛型代码里，带泛型声明的类总应该带着类型参数。但为了与老的Java代码保持一致，也允许在使用带泛型声明的类时不指定实际的类型。如果没有为这个泛型类指定实际的类型，此时被称作raw type（原始类型），默认是声明该泛型形参时指定的第一个上限类型。")]),t._v(" "),v("p",[t._v("当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都将被扔掉。比如一个 "),v("code",[t._v("List<String>")]),t._v(" 类型被转换为List，则该List对集合元素的类型检查变成了泛型参数的上限（即Object）。")]),t._v(" "),v("p",[t._v("上述规则即为泛型擦除，可以通过下面代码进一步理解泛型擦除：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),v("span",{pre:!0,attrs:{class:"token generics"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list1 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),t._v(" list2 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list1"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// list2将元素当做Object处理")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("p",[v("strong",[t._v("扩展阅读")])]),t._v(" "),v("p",[t._v("从逻辑上来看，"),v("code",[t._v("List<String>")]),t._v(" 是List的子类，如果直接把一个List对象赋给一个"),v("code",[t._v("List<String>")]),t._v("对象应该引起编译错误，但实际上不会。对泛型而言，可以直接把一个List对象赋给一个 "),v("code",[t._v("List<String>")]),t._v(" 对象，编译器仅仅提示“未经检查的转换”。")]),t._v(" "),v("p",[t._v("上述规则叫做泛型转换，可以通过下面代码进一步理解泛型转换：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),t._v(" list1 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),v("span",{pre:!0,attrs:{class:"token generics"}},[v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list2 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" list1"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 编译时警告“未经检查的转换”")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br")])]),v("h4",{attrs:{id:"_1-46-list-super-t-和list-extends-t-有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-46-list-super-t-和list-extends-t-有什么区别"}},[t._v("#")]),t._v(" 1.46 List<? super T>和List<? extends T>有什么区别？")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("ul",[v("li",[t._v("? 是类型通配符，"),v("code",[t._v("List<?>")]),t._v(" 可以表示各种泛型List的父类，意思是元素类型未知的List；")]),t._v(" "),v("li",[v("code",[t._v("List<? super T>")]),t._v(" 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型；")]),t._v(" "),v("li",[v("code",[t._v("List<? extends T>")]),t._v(" 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。")])]),t._v(" "),v("p",[v("strong",[t._v("扩展阅读")])]),t._v(" "),v("p",[t._v("在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 "),v("code",[t._v("List<Integer>")]),t._v(" 对象赋值给 "),v("code",[t._v("List<Number>")]),t._v(" 变量。")]),t._v(" "),v("p",[t._v("数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但"),v("code",[t._v("G<Foo>")]),t._v(" 不是 "),v("code",[t._v("G<Bar>")]),t._v(" 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。")]),t._v(" "),v("h4",{attrs:{id:"_1-47-说一说你对java反射机制的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-47-说一说你对java反射机制的理解"}},[t._v("#")]),t._v(" 1.47 说一说你对Java反射机制的理解")]),t._v(" "),v("p",[v("strong",[t._v("参考答案")])]),t._v(" "),v("p",[t._v("Java程序中的对象在运行时可以表现为两种类型，即编译时类型和运行时类型。例如 "),v("code",[t._v("Person p = new Student();")]),t._v(" ，这行代码将会生成一个p变量，该变量的编译时类型为Person，运行时类型为Student。")]),t._v(" "),v("p",[t._v("有时，程序在运行时接收到外部传入的一个对象，该对象的编译时类型是Object，但程序又需要调用该对象的运行时类型的方法。这就要求程序需要在运行时发现对象和类的真实信息，而解决这个问题有以下两种做法：")]),t._v(" "),v("ul",[v("li",[t._v("第一种做法是假设在编译时和运行时都完全知道类型的具体信息，在这种情况下，可以先使用instanceof运算符进行判断，再利用强制类型转换将其转换成其运行时类型的变量即可。")]),t._v(" "),v("li",[t._v("第二种做法是编译时根本无法预知该对象和类可能属于哪些类，程序只依靠运行时信息来发现该对象和类的真实信息，这就必须使用反射。")])]),t._v(" "),v("p",[t._v("具体来说，通过反射机制，我们可以实现如下的操作：")]),t._v(" "),v("ul",[v("li",[t._v("程序运行时，可以通过反射获得任意一个类的Class对象，并通过这个对象查看这个类的信息；")]),t._v(" "),v("li",[t._v("程序运行时，可以通过反射创建任意一个类的实例，并访问该实例的成员；")]),t._v(" "),v("li",[t._v("程序运行时，可以通过反射机制生成一个类的动态代理类或动态代理对象。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);