---
title: 数组
date: 2021-12-01 09:56:45
permalink: /pages/d8d641/
categories:
  - 个人笔记
  - Data Structure and Algorithm
tags:
  - 
---
```markdown
code 原作者：画手大鹏
链接：https://leetcode-cn.com/leetbook/read/illustrate-lcof/59otf1/
来源：力扣（LeetCode）

code 原作者2：CyC2018
链接：https://github.com/CyC2018/CS-Notes
来源：GitHub
```



[toc]

## 剑指 Offer 03. 数组中重复的数字

**题目描述**

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

```html
Input:
{2, 3, 1, 0, 2, 5}

Output:
2
```

<br/>

**解题思路**

-   标签：哈希
-   使用 HashSet 来进行处理，因为 HashSet 本身不允许出现重复元素，所以当添加元素失败或已经包含该数字时，则表示出现了重复元素，将其返回即可
-   时间复杂度：O(n)，空间复杂度：O(n)

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        HashSet<Integer> numsSet = new HashSet<>();
        for(int num: nums) {
            if(!numsSet.add(num)) {
                return num;
            }
        }
        return -1;
    }
}
```

<br/>

或者： 

-   要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。
-   对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。
-   以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/643b6f18-f933-4ac5-aa7a-e304dbd7fe49.gif" width="350px"> </div><br>

-   标签：哈希
-   从题目描述中我们可以看出，因为所有数字都在 0 ～ n-1 的范围内，其实完全可以省掉额外的空间开辟，将每个位置的数交换映射到其对应的数组下标下面，当出现新的元素与其对应的下标中的数字相等时，即为重复数字
-   这本质还是哈希的思想，思路 1 是使用库函数申请额外空间，思路 2 则是数组本身做哈希表，达到了节省空间的目的
-   此处会用到 while 循环，原因是保证交换过来的新元素位置也要正确
-   时间复杂度：O(n)，空间复杂度：O(1)


```java
public int duplicate(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                return  nums[i];
            }
            swap(nums, i, nums[i]);
        }
    }
    return -1;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```







## 剑指 Offer 04. 二维数组中的查找

**题目描述**

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

<br/>**解题思路**

要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35a8c711-0dc0-4613-95f3-be96c6c6e104.gif" width="400px"> </div><br>

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    
    int rows = matrix.length;
    int cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```







## 剑指 Offer 05. 替换空格

**题目描述**


将一个字符串中的空格替换成 "%20"。

```text
Input:
"A B"

Output:
"A%20B"
```

<br/>

**解题思路**

-   标签：字符串
-   最简单的方案自然是直接使用库函数啦！当然题目肯定是不希望我们这样做的！
-   增加一个新字符串，遍历原来的字符串，遍历过程中，如果非空格则将原来的字符直接拼接到新字符串中，如果遇到空格则将%20拼接到新字符串中
-   时间复杂度：O(n)，空间复杂度：O(n)

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0 ; i < s.length(); i++){
            char ch = s.charAt(i);
            if(ch == ' ') {
                sb.append("%20");
            }
            else {
                sb.append(ch);
            }
        }
        return sb.toString();
    }
}
```

<br/>

或者：

① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。

② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。

③ 当 P2 遇到 P1 时（P2 \<= P1），或者遍历结束（P1 \< 0），退出。



<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7c1fea2-c1e7-4d31-94b5-0d9df85e093c.gif" width="350px"> </div><br>

```java
public String replaceSpace(StringBuffer str) {
    int P1 = str.length() - 1;
    for (int i = 0; i <= P1; i++)
        if (str.charAt(i) == ' ')
            str.append("  ");

    int P2 = str.length() - 1;
    while (P1 >= 0 && P2 > P1) {
        char c = str.charAt(P1--);
        if (c == ' ') {
            str.setCharAt(P2--, '0');
            str.setCharAt(P2--, '2');
            str.setCharAt(P2--, '%');
        } else {
            str.setCharAt(P2--, c);
        }
    }
    return str.toString();
}
```





## 剑指 Offer 11. 旋转数组的最小数字

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。

示例 1：

```
输入：[3,4,5,1,2]
输出：1
```

示例 2：

```
输入：[2,2,2,0,1]
输出：0
```

<br/>

**思路**

-   标签：二分查找
-   整体思路：首先数组是一个有序数组的旋转，从这个条件可以看出，数组是有大小规律的，可以使用二分查找利用存在的规律快速找出结果
-   时间复杂度：O(logn)，空间复杂度：O(1)

**算法流程**

-   初始化下标 left 和 right
-   每次计算中间下标 mid = (right + left) / 2，这里的除法是取整运算，不能出现小数
-   当 numbers[mid] < numbers[right] 时，说明最小值在 [left, mid] 区间中，则令 right = mid，用于下一轮计算
-   当 numbers[mid] > numbers[right] 时，说明最小值在 [mid, right] 区间中，则令 left = mid + 1，用于下一轮计算
-   当 numbers[mid] == numbers[right] 时，无法判断最小值在哪个区间之中，此时让 right--，缩小区间范围，在下一轮进行判断
-   **为什么是 right-- 缩小范围，而不是 left++？**
    -   因为数组是升序的，所以最小值一定靠近左侧，而不是右侧
    -   比如，当存在 [1,2,2,2,2] 这种情况时，left = 0，right = 4，mid = 2，数值满足 numbers[mid] == numbers[right] 这个条件，如果 left++，则找不到最小值

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112090957439.png" style="zoom:25%;" />



```java
class Solution {
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int mid = (right + left) / 2;
            if (numbers[mid] > numbers[right]) {
                left = mid + 1;
            } else if (numbers[mid] < numbers[right]) {
                right = mid;
            } else {
                right --;
            }
        }
        return numbers[left];
    }
    
    // without duplication
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int mid = (right + left) / 2;
            if (numbers[mid] <= numbers[right])
                right = mid;
            else
                left = mid + 1;
        }
        return numbers[left];
    }
}
```

<br/>

或

```java 
class Solution {
    public int minArray(int[] numbers) {
        for(int i = 1;i < numbers.length ;i++){
            if(numbers[i] < numbers[i-1]){
                return numbers[i];
            }
        }
        return numbers[0];
    }
}
```







## 剑指 Offer 17. 打印从 1 到最大的 n 位数

**题目描述**

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```


说明：

-   用返回一个整数列表来代替打印
-   n 为正整数

<br/>

**思路**

-   标签：数组
-   整体思路：首先求出要打印的数字范围，然后再从 1 开始打印到最大的数字
-   时间复杂度：O($10^n$)，空间复杂度：O($10^n$)

**算法流程**

-   初始化 sum = 1
-   循环遍历乘 10 让 sum 变为边界值
-   新建 res 数组，大小为 sum-1
-   从 1 开始打印，直到 sum-1 为止

```java
class Solution {
    public int[] printNumbers(int n) {
        int sum = 1;
        for (int i = 0; i < n; i++) {
            sum *= 10;
        }
        int[] res = new int[sum - 1];
        for(int i = 0; i < sum - 1; i++){
            res[i] = i + 1;
        }
        return res;
    }
}
```

<br/>

或：

**思路 2**

-   标签：字符串
-   整体思路：原题的题意其实是希望考察大数计算，因为 int 数组有可能会溢出，所以用字符串处理可以保证一定不会溢出，但是呢，由于返回值规定是 int 数组，所以其实从返回值上来看，是一定不会溢出的，比较矛盾。所以给出个思路 2，学习下如何用字符串处理大数即可，不用特别纠结溢出这件事情

-   时间复杂度：O($10^n$)，空间复杂度：O($10^n$)

**算法流程 2**

-   初始化字符串 str，另其初始值为 n-1 个 "0"
-   递增 str，使用字符去递增，递增过程中判断是否存在进位，存在进位则进位处 +1，直到达到最大值为止，结束循环
-   每获取到一个值之后，遍历前方多余的 "0"，将多余的 "0" 去掉，转换为 int 存到结果数组中

```java
class Solution {
    public int[] printNumbers(int n) {
        int[] res = new int[(int)Math.pow(10, n) - 1];
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < n; i++) {
            str.append('0');
        }
        int count = 0;
        while(!increment(str)){
            int index = 0;
            
            // 去除多余的 0
            while (index < str.length() && str.charAt(index) == '0'){
                index++;
            }
            res[count] = Integer.parseInt(str.toString().substring(index));
            count++;
        }
        return res;
    }

    public boolean increment(StringBuilder str) {
        boolean isCarry = false;
        for (int i = str.length() - 1; i >= 0; i--) {
            char s = (char)(str.charAt(i) + 1);
            if (s > '9') {
                str.replace(i, i + 1, "0"); // 把 i 位置上的 char 替换掉
                if (i == 0) { // 达到最大值
                    isCarry = true;
                }
            }
            else {
                str.replace(i, i + 1, String.valueOf(s));
                break;
            }
        }
        return isCarry;
    }
}
```







## 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

**题目描述**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

 

示例：

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

**提示：**

1.  `0 <= nums.length <= 50000`
2.  `0 <= nums[i] <= 10000`

<br/>

**思路**

-   标签：双指针
-   整体思路：首先指定前指针 start 和后指针 end，然后前指针定位偶数，后指针定位奇数，定位到之后将两个值互换，直到数组遍历完成
-   时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   初始化前指针 start = 0，后指针 end = nums.length - 1
-   当 start < end 时表示该数组还未遍历完成，则继续进行奇数和偶数的交换
-   当 nums[start] 为奇数时，则 start++，直到找到不为奇数的下标为止
-   当 nums[end] 为偶数时，则 end--，直到找到不为偶数的下标为止
-   交换 nums[start] 和 nums[end]，继续下一轮交换
-   返回 nums，即为交换后的结果

```java
class Solution {
    public int[] exchange(int[] nums) {
        int start = 0;
        int end = nums.length - 1;
        
        while(start < end) {
            while(start < end && !isEven(start))
                start++;
            
            while(start < end && isEven(end)) 
                end--;
            
            swap(nums, start, end);
        }
        return nums;
    }
    
    private boolean isEven(int x) {
    	return x % 2 == 0;
	}
    
    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```







## 剑指 Offer 29. 顺时针打印矩阵

**题目描述**

按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010349296.png" width="300px"> </div><br>

<br/>

**解题思路**

-   标签：二维数组
-   整体思路：循环遍历整个数组，循环中再嵌套四个循环，分别是从左至右，从上至下，从右至左，从下至上这几个方向，按照题意将整个数组遍历完成，控制好边界
-   mm 为行数，nn 为列数，时间复杂度：O(mn)，空间复杂度：O(1)

<br/>

-   题目中 matrix 有可能为空，直接返回空数组即可
-   初始化边界 left、right、top、bottom 四个值，初始化结果数组 res 和数组下标 x
-   按照遍历方向循环取出数字放入结果数组中
-   从左至右：遍历完成后 ++top，如果 top > bottom，到达边界循环结束
-   从上至下：遍历完成后 --right，如果 left > right，到达边界循环结束
-   从右至左：遍历完成后 --bottom，如果 top > bottom，到达边界循环结束
-   从下至上：遍历完成后 ++left，如果 left > right，到达边界循环结束

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0) return new int[0];
        int left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1, x = 0;
        int[] res = new int[(right + 1) * (bottom + 1)];
        while(true) {
            for(int i = left; i <= right; i++) res[x++] = matrix[top][i];
            if(++top > bottom) break;
            for(int i = top; i <= bottom; i++) res[x++] = matrix[i][right];
            if(left > --right) break;
            for(int i = right; i >= left; i--) res[x++] = matrix[bottom][i];
            if(top > --bottom) break;
            for(int i = bottom; i >= top; i--) res[x++] = matrix[i][left];
            if(++left > right) break;
        }
        return res;
    }
}
```

<br/>

或者： 

一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行-\>从上到下打印最右一行-\>从右到左打印最下一行-\>从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010609223.png" width="500px"> </div><br>

```java
public ArrayList<Integer> printMatrix(int[][] matrix) {
    ArrayList<Integer> ret = new ArrayList<>();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 <= r2 && c1 <= c2) {
        // 上
        for (int i = c1; i <= c2; i++)
            ret.add(matrix[r1][i]);
        // 右
        for (int i = r1 + 1; i <= r2; i++)
            ret.add(matrix[i][c2]);
        if (r1 != r2)
            // 下
            for (int i = c2 - 1; i >= c1; i--)
                ret.add(matrix[r2][i]);
        if (c1 != c2)
            // 左
            for (int i = r2 - 1; i > r1; i--)
                ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}
```







## 剑指 Offer 39. 数组中出现次数超过一半的数字

**题目描述**

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 示例 1:

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

**限制：**

```1 <= 数组长度 <= 50000```

<br/>

**思路**

-   标签：摩尔投票
-   本题常见解法共有 3 种
    -   **数组排序**：首先将 nums 排序，由于该数字超过数组长度的一半，所以数组的中间元素就是答案，时间复杂度为 O(nlogn)
    -   **哈希计数**：遍历 nums 数组，将数字存在 HashMap 中，统计数字出现次数，统计完成后再遍历一次 HashMap，找到超过一半计数的数字，时间复杂度为 O(n)
    -   **摩尔投票**：遍历 nums 数组，使用 count 进行计数，记录当前出现的数字为 cur，如果遍历到的 num 与 cur 相等，则 count 自增，否则自减，当其减为 0 时则将 cur 修改为当前遍历的 num，通过增减抵消的方式，最终达到剩下的数字是结果的效果，时间复杂度为 O(n)O(n)
-   摩尔投票是最优解法，时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   初始化：预期结果 cur = 0 和计数器 count = 0
-   遍历数组 nums，遍历过程中取到的数字为 num
-   当 count 为 0 时，表示不同的数字已经将当前的结果抵消掉了，可以换新的数字进行尝试，则 cur = num
-   当 num == cur 时，表示遍历数字和预期结果相同，则计数器 count++
-   当 num != cur 时，表示遍历数字和预期结果不同，则计数器 count--
-   最终留下的数字 cur 就是最终的结果，出现次数超过一半的数字一定不会被抵消掉，最终得到了留存

```java
class Solution {
    public int majorityElement(int[] nums) {
        int cur = 0;
        int count = 0;
        for(int num : nums){
            if(count == 0) {
                cur = num;
            }
            if(num == cur) {
                count++;
            } else {
                count--;
            }
        }
        return cur;
    }
}
```







## 剑指 Offer 45. 把数组排成最小的数

**题目描述**

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 示例 1:

```
输入: [10,2]
输出: "102"
```


示例 2:

```
输入: [3,30,34,5,9]
输出: "3033459"
```

提示:

```0 < nums.length <= 100```

说明:

-   输出结果可能非常大，所以你需要返回一个字符串而不是整数
-   拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0

<br/>

**思路**

-   标签：排序

-   整体思路：
    -   拼接数组内所有元素使结果最小，本质上是排序
    -   若字符串拼接 a + b > b + a，那么排序上 b < a;
    -   根据这个规则对数组内的元素排序
-   复杂度：
    -   时间复杂度：O(n log n)。 n 为 strList 列表长度，使用 java 内置函数的平均时间复杂度为 O(n log n) ， 最差为O(n log n)
    -   空间复杂度：O(n)： 字符串列表 strList 占用线性大小的额外空间。

**算法流程**

-   将数组内的元素存入字符串列表 strList
-   根据上述排序规则，对列表进行排序
-   最后返回拼接的字符串

```java
class Solution {
    public String minNumber(int[] nums) {
        List<String> strList = new ArrayList<>();
        for (int num : nums) {
            strList.add(String.valueOf(num));
        }
        strList.sort((a, b) -> (a + b).compareTo(b + a));
        StringBuilder sb = new StringBuilder();
        for (String str : strList) {
            sb.append(str);
        }
        return sb.toString();
    }
}
```

<br/>

或：

-   快速排序

```java
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        quickSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
    void quickSort(String[] strs, int l, int r) {
        if(l >= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i < j) {
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) >= 0 && i < j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) <= 0 && i < j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        }
        strs[i] = strs[l];
        strs[l] = tmp;
        quickSort(strs, l, i - 1);
        quickSort(strs, i + 1, r);
    }
}
```







## 剑指 Offer 50. 第一个只出现一次的字符

**题目描述**

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。

```
Input: abacc
Output: b
```

<br/>

**解题思路**

最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。

考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[128];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```







## 剑指 Offer 53 - I. 在排序数组中查找数字 I

**题目描述**

-   统计一个数字在排序数组中出现的次数。

示例 1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```


示例  2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```


限制：

```0 <= 数组长度 <= 50000```

<br/>

**思路**

-   标签：数组、二分查找
-   整体思路：
    -   因为数组本身是有序的，所以利用二分查找可以降低时间复杂度，但是因为数组中的数字存在重复，所以找到 target 在数组中对应的左右边界非常重要
    -   容易想到的方式就是分别用二分查找的方式去查找 target 在数组的左边界和右边界，然后将右边界减左边界即可得到结果
    -   分别查找 target 左边界和右边界的逻辑会有差异，这里可以取巧，变成分别查找 target-1 的右边界和 target 的右边界，结果是一样的，但是代码可以进行复用了
-   复杂度：
    -   时间复杂度：O(logn)。二分查找的时间复杂度是O(logn)
    -   空间复杂度：O(1)。只需要保存左右边界和中间值即可

**算法流程**

-   首先初始化二分查找的左边界left = 0，右边界right = nums.length - 1
-   当左边界不大于右边界时进行查找
-   计算 mid = (left + right) / 2
-   如果 nums[mid] <= target，则右边界在 [mid + 1, right] 中间，令 left = mid + 1
-   如果 nums[mid] > target，则右边界在 [left, mid - 1] 中间，令 right = mid - 1
-   如果mid与target相等，left还是会右移的，会一直移动到刚好大于target的位置，也就是最后一个target之后，而当查找target-1，找到了新的left会在target-1之后位置也就是第一个target，两个位置相减就行，而如果没有找到，left跳出循环时，依然指向target第一个位置，所以循环体中那个等号的理解是关键

```java
class Solution {
    public int search(int[] nums, int target) {
        return getRightMargin(nums, target) - getRightMargin(nums, target - 1);
    }
    int getRightMargin(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```







## 剑指 Offer 53 - II. 0～n-1 中缺失的数字

**题目描述**

-   一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:

```
输入: [0,1,3]
输出: 2 
```

示例  2:

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```


限制：

```1 <= 数组长度 <= 10000```

<br/>

**思路**

-   标签：数组、二分查找
-   整体思路：
    -   缺失的数字等于 “右子数组的首位元素” 对应的索引，因此考虑使用二分法查找 “右子数组的首位元素”。
    -   左子数组： nums[i] == i
    -   右子数组： nums[i] != i
-   复杂度：
    -   时间复杂度：O(logn)
    -   空间复杂度：O(1)

**算法流程**

-   首先初始化二分查找的左边界 left = 0，右边界 right = nums.length - 1
-   当左边界不大于右边界时进行查找
-   计算 mid = (left + right) / 2
-   如果 nums[mid] == mid 则缺失的元素，即右子数组的首位元素在 [mid + 1, right] 中间，令 left = mid + 1
-   如果 nums[mid] != mid 则缺失的元素，即右子数组的首位元素在 [left, mid] 中间，令 right = mid - 1

```java
class Solution {
    public int missingNumber(int[] nums) {
        int left = 0; 
        int right = nums.length - 1; 
        while (left <= right) {
            int middle = (left + right) / 2 ; 
            if (nums[middle] == middle) 
                left = middle + 1; 
            else 
                right = middle - 1; 
        }

        return left; 
    }
}
```







## 剑指 Offer 57 - I. 和为 s 的两个数字

**题目描述**

-   输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。

示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```


示例 2：

```
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```


限制：

```1 <= nums.length <= 10^5```

```1 <= nums[i] <= 10^6```

<br/>

**思路**

-   标签：双指针
-   整体思路：因为数组本身是有序的，那么完全可以在数组的开头 start 和结尾 end 位置各设置一个指针，通过二者的加和 sum 来找到目标值 target，如果 sum < target，则 start++，这样可以让下一次的 sum 变大，如果 sum > target，则 end--，这样可以让下一次的 sum 变小，找到结果
-   时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   首先初始化 start = 0，end = nums.length - 1，作为双指针
-   当 start < end 时，始终进行循环遍历
-   计算 sum = nums[start] + nums[end]，并将 sum 与 target 进行比较
-   如果 sum < target，则需要将下一次的 sum 值变大，因为数组有序，故而 start++
-   如果 sum > target，则需要将下一次的 sum 值变小，因为数组有序，故而 end--
-   如果 sum == target，则找到了最终的结果，将结果返回即可

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while(start < end) {
            int sum = nums[start] + nums[end];
            if(sum < target) {
                start++;
            } else if(sum > target) {
                end--;
            } else {
                return new int[] { nums[start], nums[end] };
            }
        }
        return new int[0];
    }
}
```

<br/>

或：

用 Hash Map

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums.length == 0) 
            return new int[0];

        HashMap <Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            if (map.containsKey(target - num)) {
                return new int[] {num, target - num};
            } else {
                map.put(num, num);
            }
        }

        return new int[0]; 
    }
}
```







## 剑指 Offer 57 - II. 和为 s 的连续正数序列

**题目描述**

-   输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

-   序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

示例 1：

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```


示例 2：

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```


限制：

```1 <= target <= 10^5```

<br/>

**思路**

-   标签：滑动窗口、指针
-   整体思路：
    -   最容易想到的思路就是暴力枚举，因为题目条件要求至少含有两个数，所以枚举到 target/2 即可停止，时间复杂度较高
    -   更好的方式是使用滑动窗口，设立左右指针，从开始位置维护一个子数组作为窗口，判断该窗口是否求和为 target，如果是则将结果加入，如果小于 target 则窗口右移，大于 target 则窗口左移
-   复杂度：
    -   时间复杂度：O(target)。滑动窗口最多移动 target/2 次
    -   空间复杂度：O(1)。排除必要的存储结果数组之外，只需要保存左右指针

**算法流程**

-   首先初始化窗口，left=1 和 right=2
-   当 left < right 时始终维护该窗口，只有当到达边界位置时，窗口和 sum > target，left 始终右移，才会结束窗口维护
-   根据求和公式 sum = (left + right) * (right - left + 1) / 2sum=(left+right)∗(right−left+1)/2 可以直接算出滑动窗口和
-   当 sum == target 时，将窗口放入结果数组中
-   当 sum < target 时，说明窗口结果需要变大，right++
-   当 sum > target 时，说明窗口结果需要变小，left++

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int left = 1;
        int right = 2;
        ArrayList<int[]> res = new ArrayList<>();

        while (left < right) {
            int sum = (left + right) * (right - left + 1) / 2;
            if (sum == target){
                int[] arr = new int[right - left + 1];
                for (int k = left; k <= right; k++) {
                    arr[k - left] = k;
                }
                res.add(arr);
                left++;
            }
            else if (sum < target) {
                right++;
            }
            else {
                left++;
            }
        }

        return res.toArray(new int[res.size()][]);
    }
}
```







## 剑指 Offer 61. 扑克牌中的顺子

**题目描述**

-   从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

 示例 1:

```
输入: [1,2,3,4,5]
输出: True
```


示例 2:

```
输入: [0,0,1,2,5]
输出: True
```


限制：

-   数组长度为 5 

-   数组的数取值为 [0, 13] .

<br/>

思路

-   标签：数组
-   整体思路：
    -   需要对数组升序排序
    -   如果数组中有重复数据，则返回 false
    -   令 minVal 为不包含大小王的最小值，如果 maxVal-minVal > 5，则返回 false
-   复杂度：
    -   时间复杂度 O(Nlog N)
    -   空间复杂度 O(1)

算法流程

-   顺子牌的定义
    -   牌数量为 5
    -   牌间的顺序为递增，且差值为 1
    -   牌间不可以有重复数据，（大小王除外）。（扑克牌术语：如果一副牌里含有对子，则不可能是顺子）
    -   大小王可以作为任意牌，即可以作为牌间空隙插入。且数量不限
    -   牌之间的空隙个数为，maxVal-minVal
    -   由于牌数量为 5，所以 maxVal-minVal <= 5

```java
class Solution {
    public boolean isStraight(int[] nums) {
        int len = nums.length;
        if (len != 5)
            return false;

        int jkcnt = 0;
        Arrays.sort(nums);
        
        for (int i = 0; i < len; i++) {
            // 先判断，同时防止数组溢出
            if (nums[i] != 0 && i != len - 1) 
                if (nums[i] == nums[i+1]) 
                    return false;
            // 统计0的个数
            if (nums[i] == 0) {
                jkcnt++;
            }
            
        }

        return nums[len - 1] - nums[jkcnt] < 5;
    }
}
```

<br/>

或：

-   其实没有必要搞排序，而且轻松击败100%，只要满足两个条件即可，

    1.   数组除0外的数最大值最小值差值必须在4以及4以内。

    2. 除0以外的数保证不重复

-   反向思维，0既然可以代替任何数，那就别考虑它，考虑其他数，如果其他数最大最小差值大于4，那么有再多0也没用，如 1，0，0，3，6；
-   0既然可以代替任何值，那么无所谓，但是还要保证其他数不能重复，如0，0，1，1，3，这就不行了，
-   保证最大最小小于等于4，依次遍历即可（记住要除了0）
-   保证除0以外不重复，因为才5个数，而且5个数还有范围限制，直接来个标记数组即可，这样就轻松击败100%
-   代码中min初始化最低14，也可以15，。。。随便，只要不是小于扑克牌中最大值13即可

```java
public boolean isStraight(int[] nums) {
    int min = 14,max = 0;
    for(int i = 0; i < 5;i++){
        if(nums[i] > max)max = nums[i];
        if(nums[i] != 0 && nums[i] < min) min = nums[i];
    }
    if(max - min > 4) return false;
    
    // 标记数组，因为一个非零数字应该只出现一次，所以用 boolean value 标记这个数组是否出现过
    boolean[] flag = new boolean[5];
    
    for(int i = 0; i < 5; i++){
        if (nums[i] != 0) {
            if (flag[nums[i] - min] == false)
                flag[nums[i] - min] = true;
            else
                return false;
        }
    }
    return true;
}
```





## 剑指 Offer 66. 构建乘积数组

**题目描述**

-   给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

示例:

```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```


提示：

-   所有元素乘积之和不会溢出 32 位整数
-   a.length <= 100000

<br/>

**思路**

-   标签：数组遍历
-   整体思路：
    -   这道题如果可以使用除法，那么就很简单了，先求出来所有数的乘积，然后再依次除掉每个对应的值即可
    -   不让使用除法，那么最简单的思路就是将B[i]每个位置都把所有需要的数乘一遍，但是这样的时间复杂度非常高
    -   降低时间复杂度的方式就是以A[i]为界线，分割出左右三角形，其中每个三角形从尖部到底部都是可以累积的，这样就可以减少时间复杂度（具体见画）
-   复杂度：
    -   时间复杂度：O(n)。因为左右三角遍历求乘积的时间复杂度都是O(n)O(n)
    -   空间复杂度：O(1)。不将结果数组算入的话，只需要常量的空间复杂度

**算法流程**

-   首先申请结果数组 res
-   求出左侧三角从上到下的值，依次存入 res[i] 中
-   求出右侧三角从下到上的值，并且和之前的 res[i] 做乘积存入，即可得到结果

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112071006779.png" alt="image-20211207100608721" style="zoom:25%;" />

```java
class Solution {
    public int[] constructArr(int[] a) {
        int[] res = new int[a.length];
        int left = 1;
        // left 最多是 1 * 2 * 3 * 4
        for (int i = 0; i < a.length; i++) {
            res[i] = left;
            left *= a[i];
        } 
        
        // right 反向操作， 5 * 4 * 3 * 2
        int right = 1;
        for (int i = a.length - 1; i >= 0; i--) {
            res[i] *= right;
            right *= a[i];
        }
        return res;
    }
}
```







## 1. 把数组中的 0 移到末尾

283\. Move Zeroes (Easy)

[Leetcode](https://leetcode.com/problems/move-zeroes/description/) / [力扣](https://leetcode-cn.com/problems/move-zeroes/description/)

```html
For example, given nums = [0, 1, 0, 3, 12], 
after calling your function, nums should be [1, 3, 12, 0, 0].
```

```java
public void moveZeroes(int[] nums) {
    int idx = 0; // 记录非零数字的个数
    for (int num : nums)
        if (num != 0)
            nums[idx++] = num;

    while (idx < nums.length)
        nums[idx++] = 0;
}
```

**双指针：**

-   使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。
-   右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
-   注意到以下性质：
    -   左指针左边均为非零数；
    -   右指针左边直到左指针处均为零。
    -   因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int n = nums.length, left = 0, right = 0;
        while (right < n) {
            if (nums[right] != 0) {
                swap(nums, left, right); // 将左指针的零与右指针的非零数交换
                left++; // 左指针左边均为非零数, 左指针自己也指向零
            }
            right++; 	// 右指针左边直到左指针处均为零
        }
    }

    public void swap(int[] nums, int left, int right) {
        int temp = nums[left];
        nums[left] = nums[right];
        nums[right] = temp;
    }
}
```





## 2. 改变矩阵维度

566\. Reshape the Matrix (Easy)

[Leetcode](https://leetcode.com/problems/reshape-the-matrix/description/) / [力扣](https://leetcode-cn.com/problems/reshape-the-matrix/description/)

```html
Input:
nums =[[1,2],[3,4]]
r = 1, c = 4

Output:
[[1,2,3,4]]

Explanation:
The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.
```

```java
public int[][] matrixReshape(int[][] nums, int r, int c) {
    int m = nums.length, n = nums[0].length;
    if (m * n != r * c) {
        return nums;
    }
    int[][] reshapedNums = new int[r][c];
    int index = 0;
    for (int i = 0; i < r; i++) {
        for (int j = 0; j < c; j++) {
            reshapedNums[i][j] = nums[index / n][index % n];
            index++;
        }
    }
    return reshapedNums;
}

// or 
public int[][] matrixReshape(int[][] nums, int r, int c) {
    int m = nums.length;
    int n = nums[0].length;
    if (m * n != r * c) {
        return nums;
    }

    int[][] ans = new int[r][c];
    for (int x = 0; x < m * n; x++) {
        ans[x / c][x % c] = nums[x / n][x % n];
    }
    return ans;
}
```



## 3. 找出数组中最长的连续 1

485\. Max Consecutive Ones (Easy)

[Leetcode](https://leetcode.com/problems/max-consecutive-ones/description/) / [力扣](https://leetcode-cn.com/problems/max-consecutive-ones/description/)

```java
public int findMaxConsecutiveOnes(int[] nums) {
    int count = 0;
    int max = 0; 
    for (int i = 0; i < nums.length; i++) {
        count = nums[i] == 1 ? count + 1 : 0;
        max = Math.max(max, count);
    }

    return max; 
}
```



## 4. 有序矩阵查找

240\. Search a 2D Matrix II (Medium)

[Leetcode](https://leetcode.com/problems/search-a-2d-matrix-ii/description/) / [力扣](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/description/)

```html
[
   [ 1,  5,  9],
   [10, 11, 13],
   [12, 13, 15]
]
```

```java
public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
    
    int m = matrix.length, n = matrix[0].length;
    int row = 0, col = n - 1;
    
    while (row < m && col >= 0) {
        if (target == matrix[row][col]) return true;
        else if (target < matrix[row][col]) col--;
        else row++;
    }
    return false;
}
```



## 5. 有序矩阵的 Kth Element

378\. Kth Smallest Element in a Sorted Matrix ((Medium))

[Leetcode](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/description/) / [力扣](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/description/)

```html
matrix = [
  [ 1,  5,  9],
  [10, 11, 13],
  [12, 13, 15]
],
k = 8,

return 13.
```

解题参考：[Share my thoughts and Clean Java Code](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/discuss/85173)

二分查找解法 （有待优化）：

```java
public int kthSmallest(int[][] matrix, int k) {
    int m = matrix.length;
    int n = matrix[0].length;
    int lo = matrix[0][0];
    int hi = matrix[m - 1][n - 1];
    
    while (lo <= hi) {
        int mid = lo + (hi - lo) / 2;
        int cnt = 0;
        
        // count 比 mid 小的 int 的数量
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n && matrix[i][j] <= mid; j++) {
                cnt++;
            }
        }
        if (cnt < k) 
            lo = mid + 1;
        else 
            hi = mid - 1;
    }
    return lo;
}
```

归并合集：

-   由题目给出的性质可知，这个矩阵的每一行均为一个有序数组
-   问题即转化为从这 n 个有序数组中找第 k 大的数，可以想到利用归并排序的做法，归并到第 k 个数即可停止。
-   一般归并排序是两个数组归并，而本题是 n 个数组归并，所以需要用小根堆维护，以优化时间复杂度。

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] a, int[] b) {
                return a[0] - b[0];
            }
        });
        int n = matrix.length;
        
        for (int i = 0; i < n; i++)
            pq.offer(new int[]{matrix[i][0], i, 0});
        
        // 小根堆，去掉 k - 1 个堆顶元素，此时堆顶元素就是第 k 的数
        for (int i = 0; i < k - 1; i++) {
            int[] now = pq.poll();
            int row = now[1];
            int col = now[2] + 1;
            if (now[2] != n - 1)
                pq.offer(new int[]{matrix[row][col], row, col});
        }
        return pq.poll()[0];
    }
}
```





## 6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数

645\. Set Mismatch (Easy)

[Leetcode](https://leetcode.com/problems/set-mismatch/description/) / [力扣](https://leetcode-cn.com/problems/set-mismatch/description/)

```html
Input: nums = [1,2,2,4]
Output: [2,3]
```

最直接的方法是先对数组进行排序，这种方法时间复杂度为 O(NlogN)。本题可以以 O(N) 的时间复杂度、O(1) 空间复杂度来求解。

主要思想是通过交换数组元素，使得数组上的元素在正确的位置上。

因为值的范围在 [1,n]，我们可以运用「桶排序」的思路，根据 nums[i] = i + 1 的对应关系使用 O(n) 的复杂度将每个数放在其应该落在的位置里。

然后线性扫描一遍排好序的数组，找到不符合 nums[i] = i + 1 对应关系的位置，从而确定重复元素和缺失元素是哪个值。

```java
public int[] findErrorNums(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        // 因为数组里有重复的数字，所以第二个得判断他 nums[nums[i] - 1] 和  nums[i] 是不是同一个数字，如果是，就没必要换
        while (nums[i] != i + 1 && nums[nums[i] - 1] != nums[i]) {
            swap(nums, i, nums[i] - 1);
        }
    }
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] != i + 1) {
            return new int[]{nums[i], i + 1};
        }
    }
    return null;
}

private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
```

哈希表

-   重复的数字在数组中出现 2 次，丢失的数字在数组中出现 0 次，其余的每个数字在数组中出现 1 次。因此可以使用哈希表记录每个元素在数组中出现的次数，然后遍历从 1 到 nn 的每个数字，分别找到出现 2 次和出现 0 次的数字，即为重复的数字和丢失的数字。

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int[] errorNums = new int[2];
        int n = nums.length;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        for (int num : nums) {
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        for (int i = 1; i <= n; i++) {
            int count = map.getOrDefault(i, 0);
            if (count == 2) {
                errorNums[0] = i;
            } else if (count == 0) {
                errorNums[1] = i;
            }
        }
        return errorNums;
    }
}
```

-   一个朴素的做法是，使用「哈希表」统计每个元素出现次数，然后在 [1,n] 查询每个元素的出现次数。
-   在「哈希表」中出现 22 次的为重复元素，未在「哈希表」中出现的元素为缺失元素。
-   由于这里数的范围确定为 [1,n]，我们可以使用数组来充当「哈希表」，以减少「哈希表」的哈希函数执行和冲突扩容的时间开销。

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        int n = nums.length;
        int[] cnts = new int[n + 1];
        for (int x : nums) cnts[x]++;
        int[] ans = new int[2];
        for (int i = 1; i <= n; i++) {
            if (cnts[i] == 0) ans[1] = i;
            if (cnts[i] == 2) ans[0] = i;
        }
        return ans;
    }
}
```





## 7. 找出数组中重复的数，数组值在 [1, n] 之间

287\. Find the Duplicate Number (Medium)

[Leetcode](https://leetcode.com/problems/find-the-duplicate-number/description/) / [力扣](https://leetcode-cn.com/problems/find-the-duplicate-number/description/)

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `1` 到 `n` 之间（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，找出 **这个重复的数** 。

你设计的解决方案必须不修改数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

>   **输入：**nums = \[1,3,4,2,2\]
>   **输出：**2

**示例 2：**

>   **输入：**nums = \[3,1,3,4,2\]
>   **输出：**3

**示例 3：**

>   **输入：**nums = \[1,1\]
>   **输出：**1

**示例 4：**

>   **输入：**nums = \[1,1,2\]
>   **输出：**1

**提示：**

-   `1 <= n <= 105`
-   `nums.length == n + 1`
-   `1 <= nums[i] <= n`
-   `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**

**进阶：**

-   如何证明 `nums` 中至少存在一个重复的数字?
-   你可以设计一个线性级时间复杂度 `O(n)` 的解决方案吗？

-   二分查找解法：

```java
public int findDuplicate(int[] nums) {
     int l = 1, h = nums.length - 1;
     while (l <= h) {
         int mid = l + (h - l) / 2;
         int cnt = 0;
         for (int i = 0; i < nums.length; i++) {
             if (nums[i] <= mid) cnt++;
         }
         if (cnt > mid) h = mid - 1;
         else l = mid + 1;
     }
     return l;
}
```

双指针解法，类似于有环链表中找出环的入口：

```java
public int findDuplicate(int[] nums) {
    int slow = nums[0], fast = nums[nums[0]];
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[nums[fast]];
    }
    fast = 0;
    while (slow != fast) {
        slow = nums[slow];
        fast = nums[fast];
    }
    return slow;
}
```





## 8. 数组相邻差值的个数

667\. Beautiful Arrangement II (Medium)

[Leetcode](https://leetcode.com/problems/beautiful-arrangement-ii/description/) / [力扣](https://leetcode-cn.com/problems/beautiful-arrangement-ii/description/)

```html
Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.
```

题目描述：数组元素为 1\~n 的整数，要求构建数组，使得相邻元素的差值不相同的个数为 k。

让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 ... k/2 k/2+1.

```java
public int[] constructArray(int n, int k) {
    int[] ret = new int[n];
    ret[0] = 1;
    for (int i = 1, interval = k; i <= k; i++, interval--) {
        ret[i] = i % 2 == 1 ? ret[i - 1] + interval : ret[i - 1] - interval;
    }
    for (int i = k + 1; i < n; i++) {
        ret[i] = i + 1;
    }
    return ret;
}
```



## 9. 数组的度

697\. Degree of an Array (Easy)

[Leetcode](https://leetcode.com/problems/degree-of-an-array/description/) / [力扣](https://leetcode-cn.com/problems/degree-of-an-array/description/)

```html
Input: [1,2,2,3,1,4,2]
Output: 6
```

题目描述：数组的度定义为元素出现的最高频率，例如上面的数组度为 3。要求找到一个最小的子数组，这个子数组的度和原数组一样。

```java
public int findShortestSubArray(int[] nums) {
    Map<Integer, Integer> numsCnt = new HashMap<>();
    Map<Integer, Integer> numsLastIndex = new HashMap<>();
    Map<Integer, Integer> numsFirstIndex = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        numsCnt.put(num, numsCnt.getOrDefault(num, 0) + 1);
        numsLastIndex.put(num, i);
        if (!numsFirstIndex.containsKey(num)) {
            numsFirstIndex.put(num, i);
        }
    }
    int maxCnt = 0;
    for (int num : nums) {
        maxCnt = Math.max(maxCnt, numsCnt.get(num));
    }
    int ret = nums.length;
    for (int i = 0; i < nums.length; i++) {
        int num = nums[i];
        int cnt = numsCnt.get(num);
        if (cnt != maxCnt) continue;
        ret = Math.min(ret, numsLastIndex.get(num) - numsFirstIndex.get(num) + 1);
    }
    return ret;
}
```



## 10. 对角元素相等的矩阵

766\. Toeplitz Matrix (Easy)

[Leetcode](https://leetcode.com/problems/toeplitz-matrix/description/) / [力扣](https://leetcode-cn.com/problems/toeplitz-matrix/description/)

```html
1234
5123
9512

In the above grid, the diagonals are "[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]", and in each diagonal all elements are the same, so the answer is True.
```

```java
public boolean isToeplitzMatrix(int[][] matrix) {
    for (int i = 0; i < matrix[0].length; i++) {
        if (!check(matrix, matrix[0][i], 0, i)) {
            return false;
        }
    }
    for (int i = 0; i < matrix.length; i++) {
        if (!check(matrix, matrix[i][0], i, 0)) {
            return false;
        }
    }
    return true;
}

private boolean check(int[][] matrix, int expectValue, int row, int col) {
    if (row >= matrix.length || col >= matrix[0].length) {
        return true;
    }
    if (matrix[row][col] != expectValue) {
        return false;
    }
    return check(matrix, expectValue, row + 1, col + 1);
}
```



## 11. 嵌套数组

565\. Array Nesting (Medium)

[Leetcode](https://leetcode.com/problems/array-nesting/description/) / [力扣](https://leetcode-cn.com/problems/array-nesting/description/)

```html
Input: A = [5,4,0,3,1,6,2]
Output: 4
Explanation:
A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.

One of the longest S[K]:
S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}
```

题目描述：S[i] 表示一个集合，集合的第一个元素是 A[i]，第二个元素是 A[A[i]]，如此嵌套下去。求最大的 S[i]。

```java
public int arrayNesting(int[] nums) {
    int max = 0;
    for (int i = 0; i < nums.length; i++) {
        int cnt = 0;
        for (int j = i; nums[j] != -1; ) {
            cnt++;
            int t = nums[j];
            nums[j] = -1; // 标记该位置已经被访问
            j = t;

        }
        max = Math.max(max, cnt);
    }
    return max;
}
```



## 12. 分隔数组

769\. Max Chunks To Make Sorted (Medium)

[Leetcode](https://leetcode.com/problems/max-chunks-to-make-sorted/description/) / [力扣](https://leetcode-cn.com/problems/max-chunks-to-make-sorted/description/)

```html
Input: arr = [1,0,2,3,4]
Output: 4
Explanation:
We can split into two chunks, such as [1, 0], [2, 3, 4].
However, splitting into [1, 0], [2], [3], [4] is the highest number of chunks possible.
```

题目描述：分隔数组，使得对每部分排序后数组就为有序。

```java
public int maxChunksToSorted(int[] arr) {
    if (arr == null) return 0;
    int ret = 0;
    int right = arr[0];
    for (int i = 0; i < arr.length; i++) {
        right = Math.max(right, arr[i]);
        if (right == i) ret++;
    }
    return ret;
}
```



























