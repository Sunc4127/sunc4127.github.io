---
title: 字符串
date: 2021-12-22 10:48:14
permalink: /pages/308a1e/
categories:
  - 个人笔记
  - Data Structure and Algorithm
tags:
  - 
---

[toc]



## 剑指 Offer 48. 最长不含重复字符的子字符串

**题目描述**

-   请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

示例 1:

```
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是、 "abc"，所以其长度为 3。
```


示例 2:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```


示例 3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```


提示: 

-   s.length <= 40000s.length<=40000

<br/>
**思路**

-   标签：滑动窗口
-   整体思路：
    -   暴力解法时间复杂度较高，会达到 O(n^2), 故而采取滑动窗口的方法降低时间复杂度
-   复杂度：
    -   时间复杂度：O(n)。

**算法流程**

-   定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
-   我们定义不重复子串的开始位置为 start，结束位置为 end
-   随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
-   无论是否更新 start，都会更新其 map 数据结构和结果 ans。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(), ans = 0;
        
        Map<Character, Integer> map = new HashMap<>();
        
        // 不重复子串的开始位置为 start，结束位置为 end
        for (int end = 0, start = 0; end < n; end++) {
            char alpha = s.charAt(end);
            
            if (map.containsKey(alpha)) {
                // 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，
                // 此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
                start = Math.max(map.get(alpha), start);
            }
            map.put(s.charAt(end), end + 1);
            
            // value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
            ans = Math.max(ans, end - start + 1);
            
        }
        return ans;
    }
}
```

<br/>

或：

-   动态规划 + 哈希表

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();

        int res = 0, currentLongest = 0, len = s.length();

        for(int left = 0, right = 0; right < len; right++) { 
            left = dic.containsKey(s.charAt(right)) ? dic.get(s.charAt(right)) : -1; // 如果不在 dic 里，j 需要加 1 才是真正长度
            dic.put(s.charAt(right), right); // 更新哈希表
            int noRepeatLength = right - left; 
            currentLongest = currentLongest < noRepeatLength ? currentLongest + 1 : noRepeatLength; // dp[j - 1] -> dp[j]
            res = Math.max(res, currentLongest); // max(dp[j - 1], dp[j])
        }
        return res;
    }
}
```







## 剑指 Offer 58 - I. 翻转单词顺序

**题目描述**
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 "I am a student. "，则输出 "student. a am I"。

示例 1：

```
输入: "the sky is blue"
输出: "blue is sky the"
```


示例 2：

```
输入: "  hello world!  "
输出: "world! hello"
```

解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：

```
输入: "a good   example"
输出: "example good a"
```


解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

说明：

-   无空格字符构成一个单词。
-   输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
-   如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

<br/>

**思路**

-   标签：双指针
-   整体思路：先将开头和结尾处多余的空格去掉，从后向前遍历，通过前后指针锁定单词，跳过中间空格，最终将整个句子中的单词反转
-   时间复杂度：O(n)，空间复杂度：O(n)

**算法流程**

-   首先将原始字符串去掉开头和结尾的空格得到 tmp，便于之后直接从单词处理开始
-   初始化单词起始位置 start 和单词结束位置 end 指针，位置在字符串结尾处
-   初始化结果字符串 res 为空字符串
-   当 start >= 0 时，说明字符串未遍历结束，作为循环条件
-   在 tmp[start] 位置如果不为空格，说明还没有获取到完整的单词，则 start--
-   获取到完整单词之后，截取 [start+1, end+1] 这一段字符串加入结果字符串中，反转单词
-   在 tmp[start] 位置如果为空格，说明还没有到下一个单词的结尾位置，则 start--
-   到单词结尾位置之后，end = start，往复进行上述流程，将单词全部反转
-   将结果字符串 res 去掉开头和结尾多余的空格

```java
class Solution {
    public String reverseWords(String s) {
        String tmp = s.trim();
        int start = tmp.length() - 1;
        int end = tmp.length() - 1;
        String res = "";
        while(start >= 0) {
            while(start >= 0 && tmp.charAt(start) != ' ') {
                start--;
            }
            res += tmp.substring(start + 1, end + 1) + " ";
            // get rid of empty spaces 
            while(start >= 0 && tmp.charAt(start) == ' ') {
                start--;
            }
            end = start;
        }
        return res.trim();
    }
}
```

<br/>

或：

-   用 StringBuilder

```java
class Solution {
    public String reverseWords(String s) {
        if(s.length() == 0) return "";

        String[] tmp = s.trim().split(" ");
        StringBuilder res = new StringBuilder();

        for(int i = tmp.length - 1;i >= 0; i--){
            if(tmp[i].equals("")) 
                continue;
                
            res.append(tmp[i]);
            res.append(" ");
        }
        return res.toString().trim();
    }
}
```





## 剑指 Offer 58 - II. 左旋转字符串

**题目描述**
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

示例 1：

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```


示例 2：

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```


限制：

```1 <= k < s.length <= 10000```

<br/>

**思路**

-   标签：字符串遍历
-   整体思路：在原字符串处从需要反转的位置 n 开始向后遍历，并保存到结果字符串中，然后再从原字符串的初始位置遍历到位置 n，继续添加到结果字符串
-   时间复杂度：O(n)，空间复杂度：O(n)

**算法流程**

-   初始化结果字符串 res = ""，获取字符串长度 len
-   从下标 n 开始遍历，遍历到字符串 s 结尾，将区间 [n, len] 的字符添加到 res 中
-   从下标 0 开始遍历，遍历到下标 n 位置，将区间 [0, n] 的字符添加到 res 中

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        String res = "";
        int len = s.length();
        for(int i = n; i < len; i++) {
            res += s.charAt(i);
        }
        for(int i = 0; i < n; i++) {
            res += s.charAt(i);
        }
        return res;
    }
}
```

<br/>

或：

-   更简单的

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n, s.length()).concat(s.substring(0, n));
    }
}
```





## 剑指 Offer 67. 把字符串转换成整数

**题目描述**

-   写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
-   首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
-   当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
-   该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
-   注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
-   在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

-   假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为  [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或  INT_MIN (−231) 。

示例 1:

```
输入: "42"
输出: 42
```


示例 2:

```
输入: "   -42"
输出: -42

解释：第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

示例 3:

```
输入: "4193 with words"
输出: 4193

解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

示例 4:

```
输入: "4193 with words"
输出: 4193

解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```


示例 5:

```
输入: "-91283472332"
输出: -2147483648

解释：数字 "-91283472332" 超过 32 位有符号整数范围。
     因此返回 INT_MIN (−231) 。
```

<br/>
**思路**

-   标签：处理数字越界
-   整体思路：
    -   前端空格
    -   “+”，“-”正负号
    -   首个字符为非数字
    -   数字字符处理
-   复杂度：
    -   时间复杂度：O(n)O(n) ：其中 n 为字符串长度，线性遍历字符串占用 O(n)O(n) 时间
    -   空间复杂度：O(n)O(n) ： 删除首尾空格后需建立新字符串，最差情况下占用 O(n)O(n) 额外空间。

**算法流程**

-   删除首位空格
-   声明一个变量保存符号位
-   首位字符非数字直接返回
-   若为数字字符，从左向右遍历字符集，若当前数字为 x， 数字结果为 res，则遍历中 res 结果为 res = res * 10 + x
-   获得下一次遍历结果前判断是否越界，如果超过 2147483647，直接返回
-   返回结果

```java
class Solution {
    public int strToInt(String str) {
        char[] c = str.trim().toCharArray();
        if(c.length == 0) return 0;
        int res = 0, boundry = Integer.MAX_VALUE / 10;
        
        // 判断 起始位 和 正负性
        int start = 1, sign = 1;
        if(c[0] == '-') sign = -1;
        else if(c[0] != '+') start = 0;
        
        for(int i = start; i < c.length; i++) {
            
            if(c[i] < '0' || c[i] > '9') break;
            
            if(res > boundry || res == boundry && c[i] > '7') return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            
            res = res * 10 + (c[i] - '0');
        }
        return sign * res;
    }
}
```







