---
title: 数组与矩阵
date: 2021-12-01 09:56:45
permalink: /pages/d8d641/
categories:
  - 个人笔记
  - Data Structure and Algorithm
tags:
  - 
---
[toc]



## 03. 数组中重复的数字

**题目描述**

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

```html
Input:
{2, 3, 1, 0, 2, 5}

Output:
2
```

<br/>

**解题思路**

-   标签：哈希
-   使用 HashSet 来进行处理，因为 HashSet 本身不允许出现重复元素，所以当添加元素失败或已经包含该数字时，则表示出现了重复元素，将其返回即可
-   时间复杂度：O(n)，空间复杂度：O(n)

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        HashSet<Integer> numsSet = new HashSet<>();
        for(int num: nums) {
            if(!numsSet.add(num)) {
                return num;
            }
        }
        return -1;
    }
}
```

<br/>

或者： 

要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。

对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。

以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/643b6f18-f933-4ac5-aa7a-e304dbd7fe49.gif" width="350px"> </div><br>


```java
public int duplicate(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                return  nums[i];
            }
            swap(nums, i, nums[i]);
        }
        swap(nums, i, nums[i]);
    }
    return -1;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```





## 04. 二维数组中的查找

**题目描述**

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

<br/>**解题思路**

要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35a8c711-0dc0-4613-95f3-be96c6c6e104.gif" width="400px"> </div><br>

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    int rows = matrix.length, cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```





## 05. 替换空格

**题目描述**


将一个字符串中的空格替换成 "%20"。

```text
Input:
"A B"

Output:
"A%20B"
```

<br/>

**解题思路**

-   标签：字符串
-   最简单的方案自然是直接使用库函数啦！当然题目肯定是不希望我们这样做的！
-   增加一个新字符串，遍历原来的字符串，遍历过程中，如果非空格则将原来的字符直接拼接到新字符串中，如果遇到空格则将%20拼接到新字符串中
-   时间复杂度：O(n)，空间复杂度：O(n)

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0 ; i < s.length(); i++){
            char ch = s.charAt(i);
            if(ch == ' ') {
                sb.append("%20");
            }
            else {
                sb.append(ch);
            }
        }
        return sb.toString();
    }
}
```

<br/>

或者：

① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。

② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。

③ 当 P2 遇到 P1 时（P2 \<= P1），或者遍历结束（P1 \< 0），退出。



<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7c1fea2-c1e7-4d31-94b5-0d9df85e093c.gif" width="350px"> </div><br>

```java
public String replaceSpace(StringBuffer str) {
    int P1 = str.length() - 1;
    for (int i = 0; i <= P1; i++)
        if (str.charAt(i) == ' ')
            str.append("  ");

    int P2 = str.length() - 1;
    while (P1 >= 0 && P2 > P1) {
        char c = str.charAt(P1--);
        if (c == ' ') {
            str.setCharAt(P2--, '0');
            str.setCharAt(P2--, '2');
            str.setCharAt(P2--, '%');
        } else {
            str.setCharAt(P2--, c);
        }
    }
    return str.toString();
}
```





## 11. 旋转数组的最小数字

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。

示例 1：

```
输入：[3,4,5,1,2]
输出：1
```

示例 2：

```
输入：[2,2,2,0,1]
输出：0
```

<br/>

**思路**

-   标签：二分查找
-   整体思路：首先数组是一个有序数组的旋转，从这个条件可以看出，数组是有大小规律的，可以使用二分查找利用存在的规律快速找出结果
-   时间复杂度：O(logn)，空间复杂度：O(1)

**算法流程**

-   初始化下标 left 和 right
-   每次计算中间下标 mid = (right + left) / 2，这里的除法是取整运算，不能出现小数
-   当 numbers[mid] < numbers[right] 时，说明最小值在 [left, mid] 区间中，则令 right = mid，用于下一轮计算
-   当 numbers[mid] > numbers[right] 时，说明最小值在 [mid, right] 区间中，则令 left = mid + 1，用于下一轮计算
-   当 numbers[mid] == numbers[right] 时，无法判断最小值在哪个区间之中，此时让 right--，缩小区间范围，在下一轮进行判断
-   为什么是 right-- 缩小范围，而不是 left++？
    -   因为数组是升序的，所以最小值一定靠近左侧，而不是右侧
    -   比如，当存在 [1,2,2,2,2] 这种情况时，left = 0，right = 4，mid = 2，数值满足 numbers[mid] == numbers[right] 这个条件，如果 left++，则找不到最小值

```java
class Solution {
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int mid = (right + left) / 2;
            if (numbers[mid] < numbers[right]) {
                right = mid;
            } else if (numbers[mid] > numbers[right]) {
                left = mid + 1;
            } else {
                right --;
            }
        }
        return numbers[left];
    }
    
    // without duplication
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int mid = (right + left) / 2;
            if (numbers[mid] <= numbers[right])
                right = mid;
            else
                left = mid + 1;
        }
        return numbers[left];
    }
}
```

<br/>

或

```java 
class Solution {
    public int minArray(int[] numbers) {
        for(int i = 1;i < numbers.length ;i++){
            if(numbers[i] < numbers[i-1]){
                return numbers[i];
            }
        }
        return numbers[0];
    }
}
```



## 17. 打印从 1 到最大的 n 位数

**题目描述**

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```


说明：

-   用返回一个整数列表来代替打印
-   n 为正整数

<br/>

**思路**

-   标签：数组
-   整体思路：首先求出要打印的数字范围，然后再从 1 开始打印到最大的数字
-   时间复杂度：O($10^n$)，空间复杂度：O($10^n$)

**算法流程**

-   初始化 sum = 1
-   循环遍历乘 10 让 sum 变为边界值
-   新建 res 数组，大小为 sum-1
-   从 1 开始打印，直到 sum-1 为止

```java
class Solution {
    public int[] printNumbers(int n) {
        int sum = 1;
        for (int i = 0; i < n; i++) {
            sum *= 10;
        }
        int[] res = new int[sum - 1];
        for(int i = 0; i < sum - 1; i++){
            res[i] = i + 1;
        }
        return res;
    }
}
```

<br/>

或：

**思路 2**

-   标签：字符串
-   整体思路：原题的题意其实是希望考察大数计算，因为 int 数组有可能会溢出，所以用字符串处理可以保证一定不会溢出，但是呢，由于返回值规定是 int 数组，所以其实从返回值上来看，是一定不会溢出的，比较矛盾。所以给出个思路 2，学习下如何用字符串处理大数即可，不用特别纠结溢出这件事情

-   时间复杂度：O($10^n$)，空间复杂度：O($10^n$)

**算法流程 2**

-   初始化字符串 str，另其初始值为 n-1 个 "0"
-   递增 str，使用字符去递增，递增过程中判断是否存在进位，存在进位则进位处 +1，直到达到最大值为止，结束循环
-   每获取到一个值之后，遍历前方多余的 "0"，将多余的 "0" 去掉，转换为 int 存到结果数组中

```java
class Solution {
    public int[] printNumbers(int n) {
        int[] res = new int[(int)Math.pow(10, n) - 1];
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < n; i++) {
            str.append('0');
        }
        int count = 0;
        while(!increment(str)){
            int index = 0;
            
            // 去除多余的 0
            while (index < str.length() && str.charAt(index) == '0'){
                index++;
            }
            res[count] = Integer.parseInt(str.toString().substring(index));
            count++;
        }
        return res;
    }

    public boolean increment(StringBuilder str) {
        boolean isCarry = false;
        for (int i = str.length() - 1; i >= 0; i--) {
            char s = (char)(str.charAt(i) + 1);
            if (s > '9') {
                str.replace(i, i + 1, "0"); // 把 i 位置上的 char 替换掉
                if (i == 0) {
                    isCarry = true;
                }
            }
            else {
                str.replace(i, i + 1, String.valueOf(s));
                break;
            }
        }
        return isCarry;
    }
}
```



## 21. 调整数组顺序使奇数位于偶数前面

**题目描述**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

 

示例：

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

**提示：**

1.  `0 <= nums.length <= 50000`
2.  `0 <= nums[i] <= 10000`

<br/>

**思路**

-   标签：双指针
-   整体思路：首先指定前指针 start 和后指针 end，然后前指针定位偶数，后指针定位奇数，定位到之后将两个值互换，直到数组遍历完成
-   时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   初始化前指针 start = 0，后指针 end = nums.length - 1
-   当 start < end 时表示该数组还未遍历完成，则继续进行奇数和偶数的交换
-   当 nums[start] 为奇数时，则 start++，直到找到不为奇数的下标为止
-   当 nums[end] 为偶数时，则 end--，直到找到不为偶数的下标为止
-   交换 nums[start] 和 nums[end]，继续下一轮交换
-   返回 nums，即为交换后的结果

```java
class Solution {
    public int[] exchange(int[] nums) {
        int start = 0;
        int end = nums.length - 1;
        
        while(start < end) {
            while(start < end && !isEven(start))
                start++;
            
            while(start < end && isEven(end)) 
                end--;
            
            swap(nums, start, end);
        }
        return nums;
    }
    
    private boolean isEven(int x) {
    	return x % 2 == 0;
	}
    
    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```





## 29. 顺时针打印矩阵

**题目描述**

按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010349296.png" width="300px"> </div><br>

<br/>

**解题思路**

-   标签：二维数组
-   整体思路：循环遍历整个数组，循环中再嵌套四个循环，分别是从左至右，从上至下，从右至左，从下至上这几个方向，按照题意将整个数组遍历完成，控制好边界
-   mm 为行数，nn 为列数，时间复杂度：O(mn)，空间复杂度：O(1)

<br/>

-   题目中 matrix 有可能为空，直接返回空数组即可
-   初始化边界 left、right、top、bottom 四个值，初始化结果数组 res 和数组下标 x
-   按照遍历方向循环取出数字放入结果数组中
-   从左至右：遍历完成后 ++top，如果 top > bottom，到达边界循环结束
-   从上至下：遍历完成后 --right，如果 left > right，到达边界循环结束
-   从右至左：遍历完成后 --bottom，如果 top > bottom，到达边界循环结束
-   从下至上：遍历完成后 ++left，如果 left > right，到达边界循环结束

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0) return new int[0];
        int left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1, x = 0;
        int[] res = new int[(right + 1) * (bottom + 1)];
        while(true) {
            for(int i = left; i <= right; i++) res[x++] = matrix[top][i];
            if(++top > bottom) break;
            for(int i = top; i <= bottom; i++) res[x++] = matrix[i][right];
            if(left > --right) break;
            for(int i = right; i >= left; i--) res[x++] = matrix[bottom][i];
            if(top > --bottom) break;
            for(int i = bottom; i >= top; i--) res[x++] = matrix[i][left];
            if(++left > right) break;
        }
        return res;
    }
}
```

<br/>

或者： 

一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行-\>从上到下打印最右一行-\>从右到左打印最下一行-\>从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010609223.png" width="500px"> </div><br>

```java
public ArrayList<Integer> printMatrix(int[][] matrix) {
    ArrayList<Integer> ret = new ArrayList<>();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 <= r2 && c1 <= c2) {
        // 上
        for (int i = c1; i <= c2; i++)
            ret.add(matrix[r1][i]);
        // 右
        for (int i = r1 + 1; i <= r2; i++)
            ret.add(matrix[i][c2]);
        if (r1 != r2)
            // 下
            for (int i = c2 - 1; i >= c1; i--)
                ret.add(matrix[r2][i]);
        if (c1 != c2)
            // 左
            for (int i = r2 - 1; i > r1; i--)
                ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}
```





## 39. 数组中出现次数超过一半的数字

**题目描述**

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

示例 1:

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

**限制：**

```
1 <= 数组长度 <= 50000
```

<br/>

**思路**

-   标签：摩尔投票
-   本题常见解法共有 3 种
    -   **数组排序**：首先将 nums 排序，由于该数字超过数组长度的一半，所以数组的中间元素就是答案，时间复杂度为 O(nlogn)
    -   **哈希计数**：遍历 nums 数组，将数字存在 HashMap 中，统计数字出现次数，统计完成后再遍历一次 HashMap，找到超过一半计数的数字，时间复杂度为 O(n)
    -   **摩尔投票**：遍历 nums 数组，使用 count 进行计数，记录当前出现的数字为 cur，如果遍历到的 num 与 cur 相等，则 count 自增，否则自减，当其减为 0 时则将 cur 修改为当前遍历的 num，通过增减抵消的方式，最终达到剩下的数字是结果的效果，时间复杂度为 O(n)O(n)
-   摩尔投票是最优解法，时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   初始化：预期结果 cur = 0 和计数器 count = 0
-   遍历数组 nums，遍历过程中取到的数字为 num
-   当 count 为 0 时，表示不同的数字已经将当前的结果抵消掉了，可以换新的数字进行尝试，则 cur = num
-   当 num == cur 时，表示遍历数字和预期结果相同，则计数器 count++
-   当 num != cur 时，表示遍历数字和预期结果不同，则计数器 count--
-   最终留下的数字 cur 就是最终的结果，出现次数超过一半的数字一定不会被抵消掉，最终得到了留存

```java
class Solution {
    public int majorityElement(int[] nums) {
        int cur = 0;
        int count = 0;
        for(int num : nums){
            if(count == 0) {
                cur = num;
            }
            if(num == cur) {
                count++;
            } else {
                count--;
            }
        }
        return cur;
    }
}
```





## 45. 把数组排成最小的数

**题目描述**

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 

示例 1:

```
输入: [10,2]
输出: "102"
```


示例 2:

```
输入: [3,30,34,5,9]
输出: "3033459"
```



提示:

```0 < nums.length <= 100```
说明:

-   输出结果可能非常大，所以你需要返回一个字符串而不是整数
-   拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0

<br/>

**思路**

-   标签：排序

-   整体思路：
    -   拼接数组内所有元素使结果最小，本质上是排序
    -   若字符串拼接 a + b > b + a，那么排序上 b < a;
    -   根据这个规则对数组内的元素排序
-   复杂度：
    -   时间复杂度：O(n log n)。 n 为 strList 列表长度，使用 java 内置函数的平均时间复杂度为 O(n log n) ， 最差为O(n log n)
    -   空间复杂度：O(n)： 字符串列表 strList 占用线性大小的额外空间。

**算法流程**

-   将数组内的元素存入字符串列表 strList
-   根据上述排序规则，对列表进行排序
-   最后返回拼接的字符串

```java
class Solution {
    public String minNumber(int[] nums) {
        List<String> strList = new ArrayList<>();
        for (int num : nums) {
            strList.add(String.valueOf(num));
        }
        strList.sort((a, b) -> (a + b).compareTo(b + a));
        StringBuilder sb = new StringBuilder();
        for (String str : strList) {
            sb.append(str);
        }
        return sb.toString();
    }
}
```





## 50. 第一个只出现一次的字符

**题目描述**

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。

```
Input: abacc
Output: b
```

<br/>

**解题思路**

最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。

考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[128];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```



或者：

-   初始化哈希表 map，大小为 26，因为只有 26 个小写字符
-   遍历字符串 s，将遍历到的单个字符与 'a' 做减法，作为下标映射到哈希表中，比如 'b' - 'a' = 1，则位置为 map[1]
-   再次遍历字符串 s，当出现次数为 1 的时候，返回该字符

```java

class Solution {
    public char firstUniqChar(String s) {
        int[] map = new int[26];
        for(char ch : s.toCharArray()){
            map[ch - 'a']++;
        }
        for(char ch : s.toCharArray()){
            if(map[ch - 'a'] == 1) {
                return ch;
            }
        }
        return ' ';
    }
}
```





## 53 - I. 在排序数组中查找数字 I

**题目描述**

-   统计一个数字在排序数组中出现的次数。

示例 1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```


示例  2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```


限制：

```0 <= 数组长度 <= 50000```

<br/>

**思路**

-   标签：数组、二分查找
-   整体思路：
    -   因为数组本身是有序的，所以利用二分查找可以降低时间复杂度，但是因为数组中的数字存在重复，所以找到 target 在数组中对应的左右边界非常重要
    -   容易想到的方式就是分别用二分查找的方式去查找 target 在数组的左边界和右边界，然后将右边界减左边界即可得到结果
    -   分别查找 target 左边界和右边界的逻辑会有差异，这里可以取巧，变成分别查找 target-1 的右边界和 target 的右边界，结果是一样的，但是代码可以进行复用了
-   复杂度：
    -   时间复杂度：O(logn)。二分查找的时间复杂度是O(logn)
    -   空间复杂度：O(1)。只需要保存左右边界和中间值即可

**算法流程**

-   首先初始化二分查找的左边界left = 0，右边界right = nums.length - 1
-   当左边界不大于右边界时进行查找
-   计算 mid = (left + right) / 2
-   如果 nums[mid] <= target，则右边界在 [mid + 1, right] 中间，令 left = mid + 1
-   如果 nums[mid] > target，则右边界在 [left, mid - 1] 中间，令 right = mid - 1

```java
class Solution {
    public int search(int[] nums, int target) {
        return getRightMargin(nums, target) - getRightMargin(nums, target - 1);
    }
    int getRightMargin(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```





## 53 - II. 0～n-1 中缺失的数字

**题目描述**

-   一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:

```
输入: [0,1,3]
输出: 2 
```



示例  2:

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```


限制：

```1 <= 数组长度 <= 10000```

<br/>

**思路**

-   标签：数组、二分查找
-   整体思路：
    -   缺失的数字等于 “右子数组的首位元素” 对应的索引，因此考虑使用二分法查找 “右子数组的首位元素”。
    -   左子数组： nums[i] == i
    -   右子数组： nums[i] != i
-   复杂度：
    -   时间复杂度：O(logn)
    -   空间复杂度：O(1)

**算法流程**

-   首先初始化二分查找的左边界 left = 0，右边界 right = nums.length - 1
-   当左边界不大于右边界时进行查找
-   计算 mid = (left + right) / 2
-   如果 nums[mid] == mid 则缺失的元素，即右子数组的首位元素在 [mid + 1, right] 中间，令 left = mid + 1
-   如果 nums[mid] != mid 则缺失的元素，即右子数组的首位元素在 [left, mid] 中间，令 right = mid - 1

```java
class Solution {
    public int missingNumber(int[] nums) {
        int left = 0; 
        int right = nums.length - 1; 
        while (left <= right) {
            int middle = (left + right) / 2 ; 
            if (nums[middle] == middle) 
                left = middle + 1; 
            else 
                right = middle - 1; 
        }

        return left; 
    }
}
```





















