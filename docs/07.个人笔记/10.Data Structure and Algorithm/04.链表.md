---
title: 链表
date: 2021-12-11 10:03:39
permalink: /pages/4d10b6/
categories:
  - 个人笔记
  - Data Structure and Algorithm
tags:
  - 

---

```mark
作者：画手大鹏
链接：https://leetcode-cn.com/leetbook/read/illustrate-lcof/xz1ooc/
来源：力扣（LeetCode）
```



[toc]



## 剑指 Offer 18. 删除链表的节点

**题目描述**

-   给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

-   返回删除后的链表的头节点。

注意：此题对比原题有改动

示例 1:

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```


示例 2:

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```


说明：

-   题目保证链表中节点的值互不相同
-   若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点

<br/>**思路**

-   标签：链表遍历
-   整体思路是使用挨着的前后 2 个指针，当前方指针遇到要删除的值时，则使用后方指针重新构造连接并跳过该值
    -   首先判断头指针是否为 null，如果为空则直接返回 null
    -   如果头指针 head.val 即为要删除的值，则直接返回 head.next 即可
    -   初始化前指针 pre 和后指针 post，两个指针紧挨着，距离为 1
    -   前后指针一直遍历链表，直到遍历到链表结尾或等于要删除的值时则跳出循环
    -   如果找到要删除的值，则令 post.next = pre.next，相当于将链表中的值删除
    -   时间复杂度：O(n)，空间复杂度：O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        // 首先判断头指针是否为 null，如果为空则直接返回 null
        if(head == null) {
            return null;
        }
        
        // 如果头指针 head.val 即为要删除的值，则直接返回 head.next 即可
        if(head.val == val) {
            return head.next;
        }
        
        // 初始化前指针 pre 和后指针 post，两个指针紧挨着，距离为 1
        ListNode left = head;
        ListNode right = head.next;
        
        // 前后指针一直遍历链表，直到遍历到链表结尾或等于要删除的值时则跳出循环
        while(right != null && right.val != val) {
            left = right;
            right = right.next;
        }
        
        // 如果找到要删除的值，则令 post.next = pre.next，相当于将链表中的值删除
        if(right != null) {
            left.next = right.next;
        }
        return head;
    }
}
```







## 剑指 Offer 22. 链表中倒数第 k 个节点
**题目描述**

-   输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
-   例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。

 示例：

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

<br/>

**思路**

-   标签：链表遍历
-   整体思路是使用**双指针**，间隔 k 个位置，同时向后移动，当前方指针移动到尾部时，后方指针的位置就是倒数第 k 个数字
    -   首先构建前指针 pre，后指针 post
    -   前指针 pre 向前移动 k 个位置
    -   前指针 pre 和后指针 post 同时向前移动，直到前指针为 null 时停止
    -   后指针 post 即为倒数第 k 个数字
-   时间复杂度：O(n)，空间复杂度：O(1)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode pre = head;
        ListNode post = head;
        
        // 前指针 pre 向前移动 k 个位置
        for(int i = 0; i < k; i++) {
            pre = pre.next;
        }
        
        // 前指针 pre 和后指针 post 同时向前移动，直到前指针为 null 时停止
        while(pre != null) {
            pre = pre.next;
            post = post.next;
        }
        
        // 后指针 post 即为倒数第 k 个数字
        return post;
    }
}
```







## 剑指 Offer 24. 反转链表

**题目描述**

-   定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

示例:

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```


限制：

-   0 <= 节点个数 <= 5000

<br/>
**思路**

-   标签：链表遍历
-   整体思路：通过前指针、当前指针和临时指针进行位置交换，从头部开始 2 个节点为一组进行倒序交换，直到遍历到链表结尾将链表反转完成
-   时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   初始化当前指针 cur = null，前指针 pre = head
-   当 pre != null 时，说明还未到达链表结尾，则不断进行遍历交换
-   tmp = pre.next，保存下一次要进行倒转的指针位置
-   pre.next = cur，实现链表中 2 个节点的反转
-   cur = pre，cur 指针后移一个位置
-   pre = tmp，pre 指针后移一个位置
-   进行下一轮的倒转，直到结束时最终的链表头结点为 cur，返回 cur 即可

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode left = null;
        ListNode right = head;
        
        // 当 right != null 时，说明还未到达链表结尾，则不断进行遍历交换
        while (right != null) {       
            ListNode tmp = right.next; 	// 保存下一次要进行倒转的指针位置
            right.next = left;     		// 实现链表中 2 个节点的反转
            left = right;				// left  指针后移一个位置
            right = tmp;				// right 指针后移一个位置
        }
        
        // 最终的链表头结点为 cur，返回 cur 即可
        return left;
    }
}
```







## 剑指 Offer 25. 合并两个排序的链表

**题目描述**

-   输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

示例 1：

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```


限制：

-   0 <= 链表长度 <= 1000

<br/>**思路**

-   标签：链表、递归
-   这道题可以使用递归实现，新链表也不需要构造新节点
-   终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束
-   返回值：每一层调用都返回排序好的链表头
-   本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理
-   O(m+n)，mm 为 l1 的长度，nn 为 l2 的长度

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1 == null) {
            return l2;
        }
        if(l2 == null) {
            return l1;
        }

        if(l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}
```







## 剑指 Offer 52. 两个链表的第一个公共节点

**题目描述**

-   输入两个链表，找出它们的第一个公共节点。

注意：

-   如果两个链表没有交点，返回 null。
-   在返回结果后，两个链表仍须保持原有的结构。
-   可假定整个链表结构中没有循环。
-   程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。

<br/>**思路**

-   标签：双指针链表遍历
-   分别构造 2 个指针去遍历 2 个链表，**无论哪个指针到尾部时，让其重新回到对方的头部，最终会在第一个公共节点相遇，如果没有，则会在 null 处相遇**
-   时间复杂度：设 A 链表非公共长度为 m，B 链表非公共长度为 n，公共部分为 b，则复杂度为 O(m+n+b)，空间复杂度：O(1)

**算法流程**

-   使用 headA 和 headB 初始化 2 个指针 curA 和 curB，用来遍历使用
-   进行循环遍历，直到 curA 和 curB 相同时结束
-   遍历过程中如果 curA 到尾部则将其重新放回头部 headB，如果 curB 到尾部则将其重新放回头部 headA
-   循环结束时在第一个公共节点相遇，返回该节点 curA

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 用来遍历
        ListNode curA = headA;
        ListNode curB = headB;

        // 进行循环遍历，直到 curA 和 curB 相同时结束
        while (curA != curB) {
            // 遍历过程中如果 curA 到尾部则将其重新放回头部 headB，如果 curB 到尾部则将其重新放回头部 headA
            curA = curA != null ? curA.next : headB;
            curB = curB != null ? curB.next : headA;
        }
        
        // 循环结束时在第一个公共节点相遇，返回该节点 curA
        return curA;
    }
}
```

```markd
这个类似于将两个长短不一的片段拼接一下，类似于
abcijk
epijk

分别拼接对方之后
abcijkepijk
epijkabcijk
长度一样了，尾部当然也就一样了
```





















