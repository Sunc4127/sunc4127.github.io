---
title: 数组与字符串
date: 2021-12-01 09:56:45
permalink: /pages/d8d641/
categories:
  - 个人笔记
  - Data Structure and Algorithm
tags:
  - 
---
```markdown
code 原作者：画手大鹏
链接：https://leetcode-cn.com/leetbook/read/illustrate-lcof/59otf1/
来源：力扣（LeetCode）

code 原作者2：CyC2018
链接：https://github.com/CyC2018/CS-Notes
来源：GitHub
```



[toc]

# 数组



## 剑指 Offer 03. 数组中重复的数字

**题目描述**

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。

```html
Input:
{2, 3, 1, 0, 2, 5}

Output:
2
```

<br/>

**解题思路**

-   标签：哈希
-   使用 HashSet 来进行处理，因为 HashSet 本身不允许出现重复元素，所以当添加元素失败或已经包含该数字时，则表示出现了重复元素，将其返回即可
-   时间复杂度：O(n)，空间复杂度：O(n)

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        HashSet<Integer> numsSet = new HashSet<>();
        for(int num: nums) {
            if(!numsSet.add(num)) {
                return num;
            }
        }
        return -1;
    }
}
```

<br/>

或者： 

-   要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。
-   对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。
-   以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/643b6f18-f933-4ac5-aa7a-e304dbd7fe49.gif" width="350px"> </div><br>

-   标签：哈希
-   从题目描述中我们可以看出，因为所有数字都在 0 ～ n-1 的范围内，其实完全可以省掉额外的空间开辟，将每个位置的数交换映射到其对应的数组下标下面，当出现新的元素与其对应的下标中的数字相等时，即为重复数字
-   这本质还是哈希的思想，思路 1 是使用库函数申请额外空间，思路 2 则是数组本身做哈希表，达到了节省空间的目的
-   此处会用到 while 循环，原因是保证交换过来的新元素位置也要正确
-   时间复杂度：O(n)，空间复杂度：O(1)


```java
public int duplicate(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        while (nums[i] != i) {
            if (nums[i] == nums[nums[i]]) {
                return  nums[i];
            }
            swap(nums, i, nums[i]);
        }
    }
    return -1;
}

private void swap(int[] nums, int i, int j) {
    int t = nums[i];
    nums[i] = nums[j];
    nums[j] = t;
}
```







## 剑指 Offer 04. 二维数组中的查找

**题目描述**

给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。

```html
Consider the following matrix:
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]

Given target = 5, return true.
Given target = 20, return false.
```

<br/>**解题思路**

要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。

该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来快速地缩小查找区间，每次减少一行或者一列的元素。当前元素的查找区间为左下角的所有元素。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/35a8c711-0dc0-4613-95f3-be96c6c6e104.gif" width="400px"> </div><br>

```java
public boolean Find(int target, int[][] matrix) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0)
        return false;
    
    int rows = matrix.length;
    int cols = matrix[0].length;
    int r = 0, c = cols - 1; // 从右上角开始
    
    while (r <= rows - 1 && c >= 0) {
        if (target == matrix[r][c])
            return true;
        else if (target > matrix[r][c])
            r++;
        else
            c--;
    }
    return false;
}
```







## 剑指 Offer 05. 替换空格

**题目描述**


将一个字符串中的空格替换成 "%20"。

```text
Input:
"A B"

Output:
"A%20B"
```

<br/>

**解题思路**

-   标签：字符串
-   最简单的方案自然是直接使用库函数啦！当然题目肯定是不希望我们这样做的！
-   增加一个新字符串，遍历原来的字符串，遍历过程中，如果非空格则将原来的字符直接拼接到新字符串中，如果遇到空格则将%20拼接到新字符串中
-   时间复杂度：O(n)，空间复杂度：O(n)

```java
class Solution {
    public String replaceSpace(String s) {
        StringBuilder sb = new StringBuilder();
        for(int i = 0 ; i < s.length(); i++){
            char ch = s.charAt(i);
            if(ch == ' ') {
                sb.append("%20");
            }
            else {
                sb.append(ch);
            }
        }
        return sb.toString();
    }
}
```

<br/>

或者：

① 在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），所以当遍历到一个空格时，需要在尾部填充两个任意字符。

② 令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。

③ 当 P2 遇到 P1 时（P2 \<= P1），或者遍历结束（P1 \< 0），退出。



<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/f7c1fea2-c1e7-4d31-94b5-0d9df85e093c.gif" width="350px"> </div><br>

```java
public String replaceSpace(StringBuffer str) {
    int P1 = str.length() - 1;
    for (int i = 0; i <= P1; i++)
        if (str.charAt(i) == ' ')
            str.append("  ");

    int P2 = str.length() - 1;
    while (P1 >= 0 && P2 > P1) {
        char c = str.charAt(P1--);
        if (c == ' ') {
            str.setCharAt(P2--, '0');
            str.setCharAt(P2--, '2');
            str.setCharAt(P2--, '%');
        } else {
            str.setCharAt(P2--, c);
        }
    }
    return str.toString();
}
```





## 剑指 Offer 11. 旋转数组的最小数字

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。

示例 1：

```
输入：[3,4,5,1,2]
输出：1
```

示例 2：

```
输入：[2,2,2,0,1]
输出：0
```

<br/>

**思路**

-   标签：二分查找
-   整体思路：首先数组是一个有序数组的旋转，从这个条件可以看出，数组是有大小规律的，可以使用二分查找利用存在的规律快速找出结果
-   时间复杂度：O(logn)，空间复杂度：O(1)

**算法流程**

-   初始化下标 left 和 right
-   每次计算中间下标 mid = (right + left) / 2，这里的除法是取整运算，不能出现小数
-   当 numbers[mid] < numbers[right] 时，说明最小值在 [left, mid] 区间中，则令 right = mid，用于下一轮计算
-   当 numbers[mid] > numbers[right] 时，说明最小值在 [mid, right] 区间中，则令 left = mid + 1，用于下一轮计算
-   当 numbers[mid] == numbers[right] 时，无法判断最小值在哪个区间之中，此时让 right--，缩小区间范围，在下一轮进行判断
-   **为什么是 right-- 缩小范围，而不是 left++？**
    -   因为数组是升序的，所以最小值一定靠近左侧，而不是右侧
    -   比如，当存在 [1,2,2,2,2] 这种情况时，left = 0，right = 4，mid = 2，数值满足 numbers[mid] == numbers[right] 这个条件，如果 left++，则找不到最小值

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112090957439.png" style="zoom:25%;" />



```java
class Solution {
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int mid = (right + left) / 2;
            if (numbers[mid] > numbers[right]) {
                left = mid + 1;
            } else if (numbers[mid] < numbers[right]) {
                right = mid;
            } else {
                right --;
            }
        }
        return numbers[left];
    }
    
    // without duplication
    public int minArray(int[] numbers) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int mid = (right + left) / 2;
            if (numbers[mid] <= numbers[right])
                right = mid;
            else
                left = mid + 1;
        }
        return numbers[left];
    }
}
```

<br/>

或

```java 
class Solution {
    public int minArray(int[] numbers) {
        for(int i = 1;i < numbers.length ;i++){
            if(numbers[i] < numbers[i-1]){
                return numbers[i];
            }
        }
        return numbers[0];
    }
}
```







## 剑指 Offer 17. 打印从 1 到最大的 n 位数

**题目描述**

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

示例 1:

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```


说明：

-   用返回一个整数列表来代替打印
-   n 为正整数

<br/>

**思路**

-   标签：数组
-   整体思路：首先求出要打印的数字范围，然后再从 1 开始打印到最大的数字
-   时间复杂度：O($10^n$)，空间复杂度：O($10^n$)

**算法流程**

-   初始化 sum = 1
-   循环遍历乘 10 让 sum 变为边界值
-   新建 res 数组，大小为 sum-1
-   从 1 开始打印，直到 sum-1 为止

```java
class Solution {
    public int[] printNumbers(int n) {
        int sum = 1;
        for (int i = 0; i < n; i++) {
            sum *= 10;
        }
        int[] res = new int[sum - 1];
        for(int i = 0; i < sum - 1; i++){
            res[i] = i + 1;
        }
        return res;
    }
}
```

<br/>

或：

**思路 2**

-   标签：字符串
-   整体思路：原题的题意其实是希望考察大数计算，因为 int 数组有可能会溢出，所以用字符串处理可以保证一定不会溢出，但是呢，由于返回值规定是 int 数组，所以其实从返回值上来看，是一定不会溢出的，比较矛盾。所以给出个思路 2，学习下如何用字符串处理大数即可，不用特别纠结溢出这件事情

-   时间复杂度：O($10^n$)，空间复杂度：O($10^n$)

**算法流程 2**

-   初始化字符串 str，另其初始值为 n-1 个 "0"
-   递增 str，使用字符去递增，递增过程中判断是否存在进位，存在进位则进位处 +1，直到达到最大值为止，结束循环
-   每获取到一个值之后，遍历前方多余的 "0"，将多余的 "0" 去掉，转换为 int 存到结果数组中

```java
class Solution {
    public int[] printNumbers(int n) {
        int[] res = new int[(int)Math.pow(10, n) - 1];
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < n; i++) {
            str.append('0');
        }
        int count = 0;
        while(!increment(str)){
            int index = 0;
            
            // 去除多余的 0
            while (index < str.length() && str.charAt(index) == '0'){
                index++;
            }
            res[count] = Integer.parseInt(str.toString().substring(index));
            count++;
        }
        return res;
    }

    public boolean increment(StringBuilder str) {
        boolean isCarry = false;
        for (int i = str.length() - 1; i >= 0; i--) {
            char s = (char)(str.charAt(i) + 1);
            if (s > '9') {
                str.replace(i, i + 1, "0"); // 把 i 位置上的 char 替换掉
                if (i == 0) { // 达到最大值
                    isCarry = true;
                }
            }
            else {
                str.replace(i, i + 1, String.valueOf(s));
                break;
            }
        }
        return isCarry;
    }
}
```







## 剑指 Offer 21. 调整数组顺序使奇数位于偶数前面

**题目描述**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。

 

示例：

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

**提示：**

1.  `0 <= nums.length <= 50000`
2.  `0 <= nums[i] <= 10000`

<br/>

**思路**

-   标签：双指针
-   整体思路：首先指定前指针 start 和后指针 end，然后前指针定位偶数，后指针定位奇数，定位到之后将两个值互换，直到数组遍历完成
-   时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   初始化前指针 start = 0，后指针 end = nums.length - 1
-   当 start < end 时表示该数组还未遍历完成，则继续进行奇数和偶数的交换
-   当 nums[start] 为奇数时，则 start++，直到找到不为奇数的下标为止
-   当 nums[end] 为偶数时，则 end--，直到找到不为偶数的下标为止
-   交换 nums[start] 和 nums[end]，继续下一轮交换
-   返回 nums，即为交换后的结果

```java
class Solution {
    public int[] exchange(int[] nums) {
        int start = 0;
        int end = nums.length - 1;
        
        while(start < end) {
            while(start < end && !isEven(start))
                start++;
            
            while(start < end && isEven(end)) 
                end--;
            
            swap(nums, start, end);
        }
        return nums;
    }
    
    private boolean isEven(int x) {
    	return x % 2 == 0;
	}
    
    private void swap(int[] nums, int start, int end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
    }
}
```







## 剑指 Offer 29. 顺时针打印矩阵

**题目描述**

按顺时针的方向，从外到里打印矩阵的值。下图的矩阵打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010349296.png" width="300px"> </div><br>

<br/>

**解题思路**

-   标签：二维数组
-   整体思路：循环遍历整个数组，循环中再嵌套四个循环，分别是从左至右，从上至下，从右至左，从下至上这几个方向，按照题意将整个数组遍历完成，控制好边界
-   mm 为行数，nn 为列数，时间复杂度：O(mn)，空间复杂度：O(1)

<br/>

-   题目中 matrix 有可能为空，直接返回空数组即可
-   初始化边界 left、right、top、bottom 四个值，初始化结果数组 res 和数组下标 x
-   按照遍历方向循环取出数字放入结果数组中
-   从左至右：遍历完成后 ++top，如果 top > bottom，到达边界循环结束
-   从上至下：遍历完成后 --right，如果 left > right，到达边界循环结束
-   从右至左：遍历完成后 --bottom，如果 top > bottom，到达边界循环结束
-   从下至上：遍历完成后 ++left，如果 left > right，到达边界循环结束

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix.length == 0) return new int[0];
        int left = 0, right = matrix[0].length - 1, top = 0, bottom = matrix.length - 1, x = 0;
        int[] res = new int[(right + 1) * (bottom + 1)];
        while(true) {
            for(int i = left; i <= right; i++) res[x++] = matrix[top][i];
            if(++top > bottom) break;
            for(int i = top; i <= bottom; i++) res[x++] = matrix[i][right];
            if(left > --right) break;
            for(int i = right; i >= left; i--) res[x++] = matrix[bottom][i];
            if(top > --bottom) break;
            for(int i = bottom; i >= top; i--) res[x++] = matrix[i][left];
            if(++left > right) break;
        }
        return res;
    }
}
```

<br/>

或者： 

一层一层从外到里打印，观察可知每一层打印都有相同的处理步骤，唯一不同的是上下左右的边界不同了。因此使用四个变量 r1, r2, c1, c2 分别存储上下左右边界值，从而定义当前最外层。打印当前最外层的顺序：从左到右打印最上一行-\>从上到下打印最右一行-\>从右到左打印最下一行-\>从下到上打印最左一行。应当注意只有在 r1 != r2 时才打印最下一行，也就是在当前最外层的行数大于 1 时才打印最下一行，这是因为当前最外层只有一行时，继续打印最下一行，会导致重复打印。打印最左一行也要做同样处理。

<div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/image-20201104010609223.png" width="500px"> </div><br>

```java
public ArrayList<Integer> printMatrix(int[][] matrix) {
    ArrayList<Integer> ret = new ArrayList<>();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 <= r2 && c1 <= c2) {
        // 上
        for (int i = c1; i <= c2; i++)
            ret.add(matrix[r1][i]);
        // 右
        for (int i = r1 + 1; i <= r2; i++)
            ret.add(matrix[i][c2]);
        if (r1 != r2)
            // 下
            for (int i = c2 - 1; i >= c1; i--)
                ret.add(matrix[r2][i]);
        if (c1 != c2)
            // 左
            for (int i = r2 - 1; i > r1; i--)
                ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}
```







## 剑指 Offer 39. 数组中出现次数超过一半的数字

**题目描述**

数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 示例 1:

```
输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
```

**限制：**

```1 <= 数组长度 <= 50000```

<br/>

**思路**

-   标签：摩尔投票
-   本题常见解法共有 3 种
    -   **数组排序**：首先将 nums 排序，由于该数字超过数组长度的一半，所以数组的中间元素就是答案，时间复杂度为 O(nlogn)
    -   **哈希计数**：遍历 nums 数组，将数字存在 HashMap 中，统计数字出现次数，统计完成后再遍历一次 HashMap，找到超过一半计数的数字，时间复杂度为 O(n)
    -   **摩尔投票**：遍历 nums 数组，使用 count 进行计数，记录当前出现的数字为 cur，如果遍历到的 num 与 cur 相等，则 count 自增，否则自减，当其减为 0 时则将 cur 修改为当前遍历的 num，通过增减抵消的方式，最终达到剩下的数字是结果的效果，时间复杂度为 O(n)O(n)
-   摩尔投票是最优解法，时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   初始化：预期结果 cur = 0 和计数器 count = 0
-   遍历数组 nums，遍历过程中取到的数字为 num
-   当 count 为 0 时，表示不同的数字已经将当前的结果抵消掉了，可以换新的数字进行尝试，则 cur = num
-   当 num == cur 时，表示遍历数字和预期结果相同，则计数器 count++
-   当 num != cur 时，表示遍历数字和预期结果不同，则计数器 count--
-   最终留下的数字 cur 就是最终的结果，出现次数超过一半的数字一定不会被抵消掉，最终得到了留存

```java
class Solution {
    public int majorityElement(int[] nums) {
        int cur = 0;
        int count = 0;
        for(int num : nums){
            if(count == 0) {
                cur = num;
            }
            if(num == cur) {
                count++;
            } else {
                count--;
            }
        }
        return cur;
    }
}
```







## 剑指 Offer 45. 把数组排成最小的数

**题目描述**

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 示例 1:

```
输入: [10,2]
输出: "102"
```


示例 2:

```
输入: [3,30,34,5,9]
输出: "3033459"
```

提示:

```0 < nums.length <= 100```

说明:

-   输出结果可能非常大，所以你需要返回一个字符串而不是整数
-   拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0

<br/>

**思路**

-   标签：排序

-   整体思路：
    -   拼接数组内所有元素使结果最小，本质上是排序
    -   若字符串拼接 a + b > b + a，那么排序上 b < a;
    -   根据这个规则对数组内的元素排序
-   复杂度：
    -   时间复杂度：O(n log n)。 n 为 strList 列表长度，使用 java 内置函数的平均时间复杂度为 O(n log n) ， 最差为O(n log n)
    -   空间复杂度：O(n)： 字符串列表 strList 占用线性大小的额外空间。

**算法流程**

-   将数组内的元素存入字符串列表 strList
-   根据上述排序规则，对列表进行排序
-   最后返回拼接的字符串

```java
class Solution {
    public String minNumber(int[] nums) {
        List<String> strList = new ArrayList<>();
        for (int num : nums) {
            strList.add(String.valueOf(num));
        }
        strList.sort((a, b) -> (a + b).compareTo(b + a));
        StringBuilder sb = new StringBuilder();
        for (String str : strList) {
            sb.append(str);
        }
        return sb.toString();
    }
}
```

<br/>

或：

-   快速排序

```java
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        quickSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
    void quickSort(String[] strs, int l, int r) {
        if(l >= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i < j) {
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) >= 0 && i < j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) <= 0 && i < j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        }
        strs[i] = strs[l];
        strs[l] = tmp;
        quickSort(strs, l, i - 1);
        quickSort(strs, i + 1, r);
    }
}
```







## 剑指 Offer 50. 第一个只出现一次的字符

**题目描述**

在一个字符串中找到第一个只出现一次的字符，并返回它的位置。字符串只包含 ASCII 码字符。

```
Input: abacc
Output: b
```

<br/>

**解题思路**

最直观的解法是使用 HashMap 对出现次数进行统计：字符做为 key，出现次数作为 value，遍历字符串每次都将 key 对应的 value 加 1。最后再遍历这个 HashMap 就可以找出出现次数为 1 的字符。

考虑到要统计的字符范围有限，也可以使用整型数组代替 HashMap。ASCII 码只有 128 个字符，因此可以使用长度为 128 的整型数组来存储每个字符出现的次数。

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[128];
    for (int i = 0; i < str.length(); i++)
        cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++)
        if (cnts[str.charAt(i)] == 1)
            return i;
    return -1;
}
```







## 剑指 Offer 53 - I. 在排序数组中查找数字 I

**题目描述**

-   统计一个数字在排序数组中出现的次数。

示例 1:

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```


示例  2:

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```


限制：

```0 <= 数组长度 <= 50000```

<br/>

**思路**

-   标签：数组、二分查找
-   整体思路：
    -   因为数组本身是有序的，所以利用二分查找可以降低时间复杂度，但是因为数组中的数字存在重复，所以找到 target 在数组中对应的左右边界非常重要
    -   容易想到的方式就是分别用二分查找的方式去查找 target 在数组的左边界和右边界，然后将右边界减左边界即可得到结果
    -   分别查找 target 左边界和右边界的逻辑会有差异，这里可以取巧，变成分别查找 target-1 的右边界和 target 的右边界，结果是一样的，但是代码可以进行复用了
-   复杂度：
    -   时间复杂度：O(logn)。二分查找的时间复杂度是O(logn)
    -   空间复杂度：O(1)。只需要保存左右边界和中间值即可

**算法流程**

-   首先初始化二分查找的左边界left = 0，右边界right = nums.length - 1
-   当左边界不大于右边界时进行查找
-   计算 mid = (left + right) / 2
-   如果 nums[mid] <= target，则右边界在 [mid + 1, right] 中间，令 left = mid + 1
-   如果 nums[mid] > target，则右边界在 [left, mid - 1] 中间，令 right = mid - 1
-   如果mid与target相等，left还是会右移的，会一直移动到刚好大于target的位置，也就是最后一个target之后，而当查找target-1，找到了新的left会在target-1之后位置也就是第一个target，两个位置相减就行，而如果没有找到，left跳出循环时，依然指向target第一个位置，所以循环体中那个等号的理解是关键

```java
class Solution {
    public int search(int[] nums, int target) {
        return getRightMargin(nums, target) - getRightMargin(nums, target - 1);
    }
    int getRightMargin(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] <= target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```







## 剑指 Offer 53 - II. 0～n-1 中缺失的数字

**题目描述**

-   一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。

示例 1:

```
输入: [0,1,3]
输出: 2 
```

示例  2:

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```


限制：

```1 <= 数组长度 <= 10000```

<br/>

**思路**

-   标签：数组、二分查找
-   整体思路：
    -   缺失的数字等于 “右子数组的首位元素” 对应的索引，因此考虑使用二分法查找 “右子数组的首位元素”。
    -   左子数组： nums[i] == i
    -   右子数组： nums[i] != i
-   复杂度：
    -   时间复杂度：O(logn)
    -   空间复杂度：O(1)

**算法流程**

-   首先初始化二分查找的左边界 left = 0，右边界 right = nums.length - 1
-   当左边界不大于右边界时进行查找
-   计算 mid = (left + right) / 2
-   如果 nums[mid] == mid 则缺失的元素，即右子数组的首位元素在 [mid + 1, right] 中间，令 left = mid + 1
-   如果 nums[mid] != mid 则缺失的元素，即右子数组的首位元素在 [left, mid] 中间，令 right = mid - 1

```java
class Solution {
    public int missingNumber(int[] nums) {
        int left = 0; 
        int right = nums.length - 1; 
        while (left <= right) {
            int middle = (left + right) / 2 ; 
            if (nums[middle] == middle) 
                left = middle + 1; 
            else 
                right = middle - 1; 
        }

        return left; 
    }
}
```







## 剑指 Offer 57 - I. 和为 s 的两个数字

**题目描述**

-   输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，则输出任意一对即可。

示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[2,7] 或者 [7,2]
```


示例 2：

```
输入：nums = [10,26,30,31,47,60], target = 40
输出：[10,30] 或者 [30,10]
```


限制：

```1 <= nums.length <= 10^5```

```1 <= nums[i] <= 10^6```

<br/>

**思路**

-   标签：双指针
-   整体思路：因为数组本身是有序的，那么完全可以在数组的开头 start 和结尾 end 位置各设置一个指针，通过二者的加和 sum 来找到目标值 target，如果 sum < target，则 start++，这样可以让下一次的 sum 变大，如果 sum > target，则 end--，这样可以让下一次的 sum 变小，找到结果
-   时间复杂度：O(n)，空间复杂度：O(1)

**算法流程**

-   首先初始化 start = 0，end = nums.length - 1，作为双指针
-   当 start < end 时，始终进行循环遍历
-   计算 sum = nums[start] + nums[end]，并将 sum 与 target 进行比较
-   如果 sum < target，则需要将下一次的 sum 值变大，因为数组有序，故而 start++
-   如果 sum > target，则需要将下一次的 sum 值变小，因为数组有序，故而 end--
-   如果 sum == target，则找到了最终的结果，将结果返回即可

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int start = 0;
        int end = nums.length - 1;
        while(start < end) {
            int sum = nums[start] + nums[end];
            if(sum < target) {
                start++;
            } else if(sum > target) {
                end--;
            } else {
                return new int[] { nums[start], nums[end] };
            }
        }
        return new int[0];
    }
}
```

<br/>

或：

用 Hash Map

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        if (nums.length == 0) 
            return new int[0];

        HashMap <Integer, Integer> map = new HashMap<>();
        for (int num : nums) {
            if (map.containsKey(target - num)) {
                return new int[] {num, target - num};
            } else {
                map.put(num, num);
            }
        }

        return new int[0]; 
    }
}
```







## 剑指 Offer 57 - II. 和为 s 的连续正数序列

**题目描述**

-   输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

-   序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

示例 1：

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```


示例 2：

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```


限制：

```1 <= target <= 10^5```

<br/>

**思路**

-   标签：滑动窗口、指针
-   整体思路：
    -   最容易想到的思路就是暴力枚举，因为题目条件要求至少含有两个数，所以枚举到 target/2 即可停止，时间复杂度较高
    -   更好的方式是使用滑动窗口，设立左右指针，从开始位置维护一个子数组作为窗口，判断该窗口是否求和为 target，如果是则将结果加入，如果小于 target 则窗口右移，大于 target 则窗口左移
-   复杂度：
    -   时间复杂度：O(target)。滑动窗口最多移动 target/2 次
    -   空间复杂度：O(1)。排除必要的存储结果数组之外，只需要保存左右指针

**算法流程**

-   首先初始化窗口，left=1 和 right=2
-   当 left < right 时始终维护该窗口，只有当到达边界位置时，窗口和 sum > target，left 始终右移，才会结束窗口维护
-   根据求和公式 sum = (left + right) * (right - left + 1) / 2sum=(left+right)∗(right−left+1)/2 可以直接算出滑动窗口和
-   当 sum == target 时，将窗口放入结果数组中
-   当 sum < target 时，说明窗口结果需要变大，right++
-   当 sum > target 时，说明窗口结果需要变小，left++

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int left = 1;
        int right = 2;
        ArrayList<int[]> res = new ArrayList<>();

        while (left < right) {
            int sum = (left + right) * (right - left + 1) / 2;
            if (sum == target){
                int[] arr = new int[right - left + 1];
                for (int k = left; k <= right; k++) {
                    arr[k - left] = k;
                }
                res.add(arr);
                left++;
            }
            else if (sum < target) {
                right++;
            }
            else {
                left++;
            }
        }

        return res.toArray(new int[res.size()][]);
    }
}
```







## 剑指 Offer 61. 扑克牌中的顺子

**题目描述**

-   从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

 示例 1:

```
输入: [1,2,3,4,5]
输出: True
```


示例 2:

```
输入: [0,0,1,2,5]
输出: True
```


限制：

-   数组长度为 5 

-   数组的数取值为 [0, 13] .

<br/>

思路

-   标签：数组
-   整体思路：
    -   需要对数组升序排序
    -   如果数组中有重复数据，则返回 false
    -   令 minVal 为不包含大小王的最小值，如果 maxVal-minVal > 5，则返回 false
-   复杂度：
    -   时间复杂度 O(Nlog N)
    -   空间复杂度 O(1)

算法流程

-   顺子牌的定义
    -   牌数量为 5
    -   牌间的顺序为递增，且差值为 1
    -   牌间不可以有重复数据，（大小王除外）。（扑克牌术语：如果一副牌里含有对子，则不可能是顺子）
    -   大小王可以作为任意牌，即可以作为牌间空隙插入。且数量不限
    -   牌之间的空隙个数为，maxVal-minVal
    -   由于牌数量为 5，所以 maxVal-minVal <= 5

```java
class Solution {
    public boolean isStraight(int[] nums) {
        int len = nums.length;
        if (len != 5)
            return false;

        int jkcnt = 0;
        Arrays.sort(nums);
        
        for (int i = 0; i < len; i++) {
            // 先判断，同时防止数组溢出
            if (nums[i] != 0 && i != len - 1) 
                if (nums[i] == nums[i+1]) 
                    return false;
            // 统计0的个数
            if (nums[i] == 0) {
                jkcnt++;
            }
            
        }

        return nums[len - 1] - nums[jkcnt] < 5;
    }
}
```

<br/>

或：

-   其实没有必要搞排序，而且轻松击败100%，只要满足两个条件即可，

    1.   数组除0外的数最大值最小值差值必须在4以及4以内。

    2. 除0以外的数保证不重复

-   反向思维，0既然可以代替任何数，那就别考虑它，考虑其他数，如果其他数最大最小差值大于4，那么有再多0也没用，如 1，0，0，3，6；
-   0既然可以代替任何值，那么无所谓，但是还要保证其他数不能重复，如0，0，1，1，3，这就不行了，
-   保证最大最小小于等于4，依次遍历即可（记住要除了0）
-   保证除0以外不重复，因为才5个数，而且5个数还有范围限制，直接来个标记数组即可，这样就轻松击败100%
-   代码中min初始化最低14，也可以15，。。。随便，只要不是小于扑克牌中最大值13即可

```java
public boolean isStraight(int[] nums) {
    int min = 14,max = 0;
    for(int i = 0; i < 5;i++){
        if(nums[i] > max)max = nums[i];
        if(nums[i] != 0 && nums[i] < min) min = nums[i];
    }
    if(max - min > 4) return false;
    
    // 标记数组，因为一个非零数字应该只出现一次，所以用 boolean value 标记这个数组是否出现过
    boolean[] flag = new boolean[5];
    
    for(int i = 0; i < 5; i++){
        if (nums[i] != 0) {
            if (flag[nums[i] - min] == false)
                flag[nums[i] - min] = true;
            else
                return false;
        }
    }
    return true;
}
```





## 剑指 Offer 66. 构建乘积数组

**题目描述**

-   给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。

示例:

```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```


提示：

-   所有元素乘积之和不会溢出 32 位整数
-   a.length <= 100000

<br/>

**思路**

-   标签：数组遍历
-   整体思路：
    -   这道题如果可以使用除法，那么就很简单了，先求出来所有数的乘积，然后再依次除掉每个对应的值即可
    -   不让使用除法，那么最简单的思路就是将B[i]每个位置都把所有需要的数乘一遍，但是这样的时间复杂度非常高
    -   降低时间复杂度的方式就是以A[i]为界线，分割出左右三角形，其中每个三角形从尖部到底部都是可以累积的，这样就可以减少时间复杂度（具体见画）
-   复杂度：
    -   时间复杂度：O(n)。因为左右三角遍历求乘积的时间复杂度都是O(n)O(n)
    -   空间复杂度：O(1)。不将结果数组算入的话，只需要常量的空间复杂度

**算法流程**

-   首先申请结果数组 res
-   求出左侧三角从上到下的值，依次存入 res[i] 中
-   求出右侧三角从下到上的值，并且和之前的 res[i] 做乘积存入，即可得到结果

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112071006779.png" alt="image-20211207100608721" style="zoom:25%;" />

```java
class Solution {
    public int[] constructArr(int[] a) {
        int[] res = new int[a.length];
        int left = 1;
        // left 最多是 1 * 2 * 3 * 4
        for (int i = 0; i < a.length; i++) {
            res[i] = left;
            left *= a[i];
        } 
        
        // right 反向操作， 5 * 4 * 3 * 2
        int right = 1;
        for (int i = a.length - 1; i >= 0; i--) {
            res[i] *= right;
            right *= a[i];
        }
        return res;
    }
}
```







# **字符串**



## 剑指 Offer 48. 最长不含重复字符的子字符串

**题目描述**

-   请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

示例 1:

```
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是、 "abc"，所以其长度为 3。
```


示例 2:

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```


示例 3:

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```


提示: 

-   s.length <= 40000s.length<=40000

<br/>
**思路**

-   标签：滑动窗口
-   整体思路：
    -   暴力解法时间复杂度较高，会达到 O(n^2), 故而采取滑动窗口的方法降低时间复杂度
-   复杂度：
    -   时间复杂度：O(n)。

**算法流程**

-   定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
-   我们定义不重复子串的开始位置为 start，结束位置为 end
-   随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
-   无论是否更新 start，都会更新其 map 数据结构和结果 ans。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length(), ans = 0;
        
        Map<Character, Integer> map = new HashMap<>();
        
        // 不重复子串的开始位置为 start，结束位置为 end
        for (int end = 0, start = 0; end < n; end++) {
            char alpha = s.charAt(end);
            
            if (map.containsKey(alpha)) {
                // 随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，
                // 此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符
                start = Math.max(map.get(alpha), start);
            }
            map.put(s.charAt(end), end + 1);
            
            // value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复
            ans = Math.max(ans, end - start + 1);
            
        }
        return ans;
    }
}
```

<br/>

或：

-   动态规划 + 哈希表

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();

        int res = 0, currentLongest = 0, len = s.length();

        for(int left = 0, right = 0; right < len; right++) { 
            left = dic.containsKey(s.charAt(right)) ? dic.get(s.charAt(right)) : -1; // 如果不在 dic 里，j 需要加 1 才是真正长度
            dic.put(s.charAt(right), right); // 更新哈希表
            int noRepeatLength = right - left; 
            currentLongest = currentLongest < noRepeatLength ? currentLongest + 1 : noRepeatLength; // dp[j - 1] -> dp[j]
            res = Math.max(res, currentLongest); // max(dp[j - 1], dp[j])
        }
        return res;
    }
}
```







## 剑指 Offer 58 - I. 翻转单词顺序

**题目描述**
输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串 "I am a student. "，则输出 "student. a am I"。

示例 1：

```
输入: "the sky is blue"
输出: "blue is sky the"
```


示例 2：

```
输入: "  hello world!  "
输出: "world! hello"
```

解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：

```
输入: "a good   example"
输出: "example good a"
```


解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

说明：

-   无空格字符构成一个单词。
-   输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
-   如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

<br/>

**思路**

-   标签：双指针
-   整体思路：先将开头和结尾处多余的空格去掉，从后向前遍历，通过前后指针锁定单词，跳过中间空格，最终将整个句子中的单词反转
-   时间复杂度：O(n)，空间复杂度：O(n)

**算法流程**

-   首先将原始字符串去掉开头和结尾的空格得到 tmp，便于之后直接从单词处理开始
-   初始化单词起始位置 start 和单词结束位置 end 指针，位置在字符串结尾处
-   初始化结果字符串 res 为空字符串
-   当 start >= 0 时，说明字符串未遍历结束，作为循环条件
-   在 tmp[start] 位置如果不为空格，说明还没有获取到完整的单词，则 start--
-   获取到完整单词之后，截取 [start+1, end+1] 这一段字符串加入结果字符串中，反转单词
-   在 tmp[start] 位置如果为空格，说明还没有到下一个单词的结尾位置，则 start--
-   到单词结尾位置之后，end = start，往复进行上述流程，将单词全部反转
-   将结果字符串 res 去掉开头和结尾多余的空格

```java
class Solution {
    public String reverseWords(String s) {
        String tmp = s.trim();
        int start = tmp.length() - 1;
        int end = tmp.length() - 1;
        String res = "";
        while(start >= 0) {
            while(start >= 0 && tmp.charAt(start) != ' ') {
                start--;
            }
            res += tmp.substring(start + 1, end + 1) + " ";
            // get rid of empty spaces 
            while(start >= 0 && tmp.charAt(start) == ' ') {
                start--;
            }
            end = start;
        }
        return res.trim();
    }
}
```

<br/>

或：

-   用 StringBuilder

```java
class Solution {
    public String reverseWords(String s) {
        if(s.length() == 0) return "";

        String[] tmp = s.trim().split(" ");
        StringBuilder res = new StringBuilder();

        for(int i = tmp.length - 1;i >= 0; i--){
            if(tmp[i].equals("")) 
                continue;
                
            res.append(tmp[i]);
            res.append(" ");
        }
        return res.toString().trim();
    }
}
```





## 剑指 Offer 58 - II. 左旋转字符串

**题目描述**
字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

示例 1：

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```


示例 2：

```
输入: s = "lrloseumgh", k = 6
输出: "umghlrlose"
```


限制：

```1 <= k < s.length <= 10000```

<br/>

**思路**

-   标签：字符串遍历
-   整体思路：在原字符串处从需要反转的位置 n 开始向后遍历，并保存到结果字符串中，然后再从原字符串的初始位置遍历到位置 n，继续添加到结果字符串
-   时间复杂度：O(n)，空间复杂度：O(n)

**算法流程**

-   初始化结果字符串 res = ""，获取字符串长度 len
-   从下标 n 开始遍历，遍历到字符串 s 结尾，将区间 [n, len] 的字符添加到 res 中
-   从下标 0 开始遍历，遍历到下标 n 位置，将区间 [0, n] 的字符添加到 res 中

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        String res = "";
        int len = s.length();
        for(int i = n; i < len; i++) {
            res += s.charAt(i);
        }
        for(int i = 0; i < n; i++) {
            res += s.charAt(i);
        }
        return res;
    }
}
```

<br/>

或：

-   更简单的

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        return s.substring(n, s.length()).concat(s.substring(0, n));
    }
}
```





## 剑指 Offer 67. 把字符串转换成整数

**题目描述**

-   写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
-   首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
-   当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
-   该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
-   注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
-   在任何情况下，若函数不能进行有效的转换时，请返回 0。

说明：

-   假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为  [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或  INT_MIN (−231) 。

示例 1:

```
输入: "42"
输出: 42
```


示例 2:

```
输入: "   -42"
输出: -42

解释：第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

示例 3:

```
输入: "4193 with words"
输出: 4193

解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

示例 4:

```
输入: "4193 with words"
输出: 4193

解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```


示例 5:

```
输入: "-91283472332"
输出: -2147483648

解释：数字 "-91283472332" 超过 32 位有符号整数范围。
     因此返回 INT_MIN (−231) 。
```

<br/>
**思路**

-   标签：处理数字越界
-   整体思路：
    -   前端空格
    -   “+”，“-”正负号
    -   首个字符为非数字
    -   数字字符处理
-   复杂度：
    -   时间复杂度：O(n)O(n) ：其中 n 为字符串长度，线性遍历字符串占用 O(n)O(n) 时间
    -   空间复杂度：O(n)O(n) ： 删除首尾空格后需建立新字符串，最差情况下占用 O(n)O(n) 额外空间。

**算法流程**

-   删除首位空格
-   声明一个变量保存符号位
-   首位字符非数字直接返回
-   若为数字字符，从左向右遍历字符集，若当前数字为 x， 数字结果为 res，则遍历中 res 结果为 res = res * 10 + x
-   获得下一次遍历结果前判断是否越界，如果超过 2147483647，直接返回
-   返回结果

```java
class Solution {
    public int strToInt(String str) {
        char[] c = str.trim().toCharArray();
        if(c.length == 0) return 0;
        int res = 0, boundry = Integer.MAX_VALUE / 10;
        
        // 判断 起始位 和 正负性
        int start = 1, sign = 1;
        if(c[0] == '-') sign = -1;
        else if(c[0] != '+') start = 0;
        
        for(int i = start; i < c.length; i++) {
            
            if(c[i] < '0' || c[i] > '9') break;
            
            if(res > boundry || res == boundry && c[i] > '7') return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            
            res = res * 10 + (c[i] - '0');
        }
        return sign * res;
    }
}
```











































