---
title: Data Structure
date: 2021-11-07 12:20:40
permalink: /pages/477256/
categories:
  - Data Structure and Algorithm
tags:
  - 
---

[toc]



## 前言

-   数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。不同的数据结构具有各自对应的适用场景，旨在**降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率**。
-   如下图所示，常见的数据结构可分为「线性数据结构」与「非线性数据结构」，具体为：「数组」、「链表」、「栈」、「队列」、「树」、「图」、「散列表」、「堆」。



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111141154904.png" alt="image-20211114115410875" style="zoom:25%;"/>


-   根据输入数据的特点，时间复杂度具有「最差」、「平均」、「最佳」三种情况，分别使用 O , Θ , Ω 三种符号表示
-   根据从小到大排列，常见的算法时间复杂度主要有：(Big O notation) To describe the performance of an algorithm (Scale well or not)
-   O(1) < O(log N) < O(N) < O(N log N) < O(N^2) < O(2^N) < O(N!):

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111180934419.png" alt="image-20211118093438371" style="zoom:17.5%;" />



-   Comparison: 

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111181001670.png" alt="9- Cheat Sheet" style="zoom:25%;" />



### O(1)

```java
public void log(int[] numbers) {
    System.out.println(numbers[0]); // O(1)
}
```



-   Runs in constant time 
-   Size of the input does not matter 
-   Only run one time 
    -   Constant Time



### O(n)

```java
public void log(int[] numbers) {
    for (int number : numbers)
        System.out.println(number);
}
```



-   Linear growth
-   One for loop
-   Depends on the size of the input 



### O(n^2 )

```java
public void log(int[] numbers) {
    for (int first : numbers)
        for (int second: numbers)
        	System.out.println(first + "," + second);
}
```



-   Runs in quadratic time



### O(log n)

-   More efficient than linear or quadratic growth 



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111180929197.png" alt="image-20211118092940940" style="zoom:15%;" />



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111180932426.png" alt="image-20211118093219355" style="zoom:25%;" />





### O(2^n)



-   The opposite of logarithmic growth 



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111180933301.png" alt="image-20211118093319270" style="zoom:15%;" />





### Space Complexity 

```java
// think about how much extra space needs to be allocated for this algorithm 
public void greet(String[] names) {
    // O(1)
    for (String name : names)
        System.out.prinlnt("Hi" + name);
    
    // O(n)
    String[] copy = new String[names.length];
}
```





## 数组 (Array)

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111141158467.png" alt="image-20211114115838435" style="zoom:25%;" />

-   数组是将**相同类型**的元素存储于**连续内存空间**的数据结构，其**长度不可变**。
-   构建此数组需要**在初始化时给定长度**，并对数组每个索引元素赋值

```java
// 初始化一个长度为 5 的数组 array
int[] array = new int[5];
// 元素赋值
array[0] = 2;
array[1] = 3;
array[2] = 1;
array[3] = 0;
array[4] = 2;

// 直接赋值
int[] array = {2, 3, 1, 0, 2};
```






-   **「可变数组」**是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。

```java
// 初始化可变数组
List<Integer> array = new ArrayList<>();

// 向尾部添加元素
array.add(2);
array.add(3);
array.add(1);
array.add(0);
array.add(2);
```



## 链表 (ListNode)

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111141158836.png" alt="image-20211114115851801" style="zoom:25%;" />

-   链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是**非连续**的。
-   链表的节点对象具有两个成员变量：「值 `val`」，「后继节点引用 `next`」 。
-   如下图所示，建立此链表需要实例化每个节点，并构建各节点的引用指向。

```java
class ListNode {
    int val;       // 节点值
    ListNode next; // 后继节点引用
    ListNode(int x) { val = x; }
}

// 实例化节点
ListNode n1 = new ListNode(4); // 节点 head
ListNode n2 = new ListNode(5);
ListNode n3 = new ListNode(1);

// 构建引用指向
n1.next = n2;
n2.next = n3;

```






## 栈（Stack）

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111181105899.png" alt="image-20211118110542866" style="zoom:25%;" />

-   栈是一种具有 「先入后出」 特点的抽象数据结构，可使用数组或链表实现。
-   通过常用操作「入栈 `push()`」,「出栈 `pop()`」，展示了栈的先入后出特性。

```java
Stack<Integer> stack = new Stack<>();

stack.push(1); // 元素 1 入栈
stack.push(2); // 元素 2 入栈
stack.pop();   // 出栈 -> 元素 2
stack.pop();   // 出栈 -> 元素 1
```

-   注意：通常情况下，不推荐使用 Java 的 `Vector` 以及其子类 `Stack` ，而一般将 `LinkedList` 作为栈来使用。

```java
LinkedList<Integer> stack = new LinkedList<>();

stack.addLast(1);   // 元素 1 入栈
stack.addLast(2);   // 元素 2 入栈
stack.removeLast(); // 出栈 -> 元素 2
stack.removeLast(); // 出栈 -> 元素 1
```






## 队列 （Queue）

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111181106443.png" alt="image-20211118110621415" style="zoom:25%;" />

-   队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。
-   通过常用操作「入队 `offer()`」,「出队 `poll()`」，展示了队列的先入先出特性。

```java
Queue<Integer> queue = new LinkedList<>();

queue.offer(1); // 元素 1 入队
queue.offer(2); // 元素 2 入队
queue.poll();   // 出队 -> 元素 1
queue.poll();   // 出队 -> 元素 2
```










## 树 (Tree)

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111210925020.png" alt="image-20211121092501970" style="zoom:25%;" />

-   树是一种非线性数据结
-   根据子节点数量可分为 「二叉树」 和 「多叉树」
-   最顶层的节点称为「根节点 root」
-   以二叉树为例，每个节点包含三个成员变量：
    -   「值 val」
    -   「左子节点 left」
    -   「右子节点 right」 
-   建立此二叉树需要实例化每个节点，并构建各节点的引用指向

```java
class TreeNode {
    int val;        // 节点值
    TreeNode left;  // 左子节点
    TreeNode right; // 右子节点
    TreeNode(int x) { val = x; }
}

// 初始化节点
TreeNode n1 = new TreeNode(3); // 根节点 root
TreeNode n2 = new TreeNode(4);
TreeNode n3 = new TreeNode(5);
TreeNode n4 = new TreeNode(1);
TreeNode n5 = new TreeNode(2);

// 构建引用指向
n1.left = n2;
n1.right = n3;
n2.left = n4;
n2.right = n5;
```





## 图 (Graph)

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202111210928902.png" alt="image-20211121092849875" style="zoom:25%;" />

-   图是一种非线性数据结构，由「节点（顶点）vertex」和「边 edge」组成，每条边连接一对顶点
-   根据边的方向有无，图可分为「有向图」和「无向图」

表示图的方法通常有两种：

### 邻接矩阵

-   使用数组 vertices 存储顶点，邻接矩阵 edges 存储边
-   Edges [i] [j]代表节点 i + 1 和 节点 j + 1 之间是否有边。

```java
int[] vertices = {1, 2, 3, 4, 5};
int[][] edges = {{0, 1, 1, 1, 1},
                 {1, 0, 0, 1, 0},
                 {1, 0, 0, 0, 1},
                 {1, 1, 0, 0, 1},
                 {1, 0, 1, 1, 0}};
```



### 邻接表

-   使用数组 vertices 存储顶点，邻接表 edges 存储边
-   edges 为一个二维容器，第一维 i 代表顶点索引，第二维 edges[i] 存储此顶点对应的边集合
-   例如 edges[0] = [1, 2, 3, 4] 代表 vertices[0] 的边集合为 [1, 2, 3, 4][1,2,3,4] 。

```java
int[] vertices = {1, 2, 3, 4, 5};
List<List<Integer>> edges = new ArrayList<>();

List<Integer> edge_1 = new ArrayList<>(Arrays.asList(1, 2, 3, 4));
List<Integer> edge_2 = new ArrayList<>(Arrays.asList(0, 3));
List<Integer> edge_3 = new ArrayList<>(Arrays.asList(0, 4));
List<Integer> edge_4 = new ArrayList<>(Arrays.asList(0, 1, 4));
List<Integer> edge_5 = new ArrayList<>(Arrays.asList(0, 2, 3));

edges.add(edge_1);
edges.add(edge_2);
edges.add(edge_3);
edges.add(edge_4);
edges.add(edge_5);
```



### 邻接矩阵 VS 邻接表 ：

-   邻接矩阵的大小只与节点数量有关，即 $N^2$，其中 N 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费
-   因此，
    -   **邻接表** 适合存储稀疏图（顶点较多、边较少）； 
    -   **邻接矩阵** 适合存储稠密图（顶点较少、边较多）。



## 散列表 （Hash Table）



<img src="https://pic.leetcode-cn.com/1599811794-ruXMOV-Picture8.png" alt="Picture8.png" style="zoom: 33%;" />

```java
String[] names = { "小力", "小特", "小扣" };

// 一个简单的 Hash 函数（ % 为取余符号 ）
int hash(int id) {
    int index = (id - 1) % 10000;
    return index;
}

// 构建了以学号为 key 、姓名对应的数组索引为 value 的散列表。利用此 Hash 函数，则可在 O(1) 时间复杂度下通过学号查找到对应姓名: 

names[hash(10001)] // 小力
names[hash(10002)] // 小特
names[hash(10003)] // 小扣
    
// 实际的 Hash 函数需保证低碰撞率、 高健壮性
```



<img src="https://pic.leetcode-cn.com/1599811794-NfbpfW-Picture8-1.png" alt="Picture8-1.png" style="zoom: 33%;" />



## 堆 （Heap）

<img src="https://pic.leetcode-cn.com/1599584901-xoiGEQ-Picture9.png" alt="Picture9.png" style="zoom:33%;" />

-   堆是一种基于「完全二叉树」的数据结构，可使用数组实现
-   以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」
-   堆分为「大顶堆」和「小顶堆」，
    -   大（小）顶堆：任意节点的值不大于（小于）其父节点的值。

-   完全二叉树定义： 
    -   设二叉树深度为 k ，若二叉树除第 k 层外的其它各层（第 1 至 k-1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。
    -   如上图所示，为包含 `1, 4, 2, 6, 8` 元素的小顶堆。将堆（完全二叉树）中的结点按层编号，即可映射到右边的数组存储形式。

-   通过使用「优先队列」的「压入 `push()`」和「弹出 `pop()`」操作，即可完成堆排序：

```java
// 初始化小顶堆
Queue<Integer> heap = new PriorityQueue<>();

// 元素入堆
heap.add(1);
heap.add(4);
heap.add(2);
heap.add(6);
heap.add(8);

// 元素出堆（从小到大）
heap.poll(); // -> 1
heap.poll(); // -> 2
heap.poll(); // -> 4
heap.poll(); // -> 6
heap.poll(); // -> 8
```

