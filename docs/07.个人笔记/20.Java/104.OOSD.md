---
title: Untitled
date: 2021-12-07 15:08:52
permalink: /pages/af3594/
categories:
  - 个人笔记
  - Java
tags:
  - 
---

[toc]

## Paradigms 



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112071509320.png" alt="image-20211207150938272" style="zoom: 25%;" />

-   There are many paradigms





<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112071510853.png" alt="image-20211207151015815" style="zoom:25%;" />



-   Different languages support different paradigms



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112071510794.png" alt="image-20211207151040748" style="zoom:25%;" /> 

-   In OOSD, everything is based on the concept of ```Object```
-   Objects are units that contain
    -   ==Data (State)==
    -   ==Methods (Behavior) (operation on the date)==





<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112071514249.png" alt="image-20211207151437208" style="zoom:25%;" />

-   Object-oriented: 
    -   Complex
    -   data and behavior are in a single object 
-   Functional: keep them separate



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112071517115.png" alt="image-20211207151741067" style="zoom:25%;" />

-   That is, it depends 
-   It depends on the problem one is trying to solve 
-   No paradigm works best in all situations 
-   No such a thing as ```one size fits all ```







## Benefits of OOSD

-   Modular 
    -   Reduced complexity 
    -   Easier maintenance 
    -   Code reuse 
    -   Faster development 





## Classes

-   **Class** 

    -   A blueprint/template for creating objects 

-   **Object** 

    -   An instance of a class

    

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112081451361.png" alt="image-20211208145106321" style="zoom: 25%;" />

-   **Methods** can change the value of **fields** 
-   Different car instances have different states 
    -   They are independent objects stored in different locations of memory 



-   Example: create the TextBox class 

```java
public class TextBox {
  // declare field
  // should initialize the field to avoid null pointer exception
  public String text = "";

  public void setText(String text) {
    this.text = text;
  }

  public void clear() {
    // don't need to use 'this'
    text = "";
  }
}
```

-   Example: create TextBox objects 

```java
public class Main {
    public static void main(String[] args) {
        // use 'var' to replace 'TextBox'
        var textBox1 = new TextBox();
        textBox1.setText("Box 1");
        System.out.println(textBox1.text.toLowerCase());

        // they are completely independent of each other
        var textBox2 = new TextBox();
        textBox2.setText("Box 2");
        System.out.println(textBox2.text.toUpperCase());
    }
}
```







## Memory Allocation

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112081523789.png" alt="image-20211208152347746" style="zoom:25%;" />

-   **Heap** store objects 
-   **Stack** store primitives short-lived variables (store references to objects on the heap)

```java
public class Main {

    public static void main(String[] args) {
        // the newly created object is stored on the heap;
        // the address of the text object is stored on the stack; so 'textBox1' is a reference type 
        var textBox1 = new TextBox();
        var textBox2 = textBox1; // reference the same TextBox object
        textBox2.setText("Box 2");
        System.out.println(textBox1.text); // get "Box 2"
    }
}
```

-   All memory on the stack will be immediately removed after finishing executing the main function
-   That is, memory deallocation is automatically handled by Java       
-   **Garbage collector** will remove unused objects on the heap







## Encapsulation

-   Bundle the data and methods that operate on the data in a single unit

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112081559571.png" alt="image-20211208155940513" style="zoom:25%;" />

-   By clicking the lightbulb, IntelliJ can help to create getters and setters 







## Abstraction

-   **Reduce complexity** by hiding unnecessary details 
    -   Hide the implementation details of a class and treat it as a **black box** 
    -   Have a simple interface to work with 







## Coupling 

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112091441074.png" alt="image-20211209144155989" style="zoom:15%;" />

-   The **level of dependency** among classes 
-   The more  classes are coupled to each other, the more costly our changes are going to be
-   By reducing the coupling, we can reduce the impact of changes 
    -   Reduce coupling points by reducing the number of unnecessary getter & setter functions 



```java
public class Browser {
  // only navigate is public
  public void navigate(String address) {
    String ip = findIpAddress(address);
    String html = sendHttpRequest(ip);
    System.out.println(html);
  }

  // hide from other classes, only used internally
  private String sendHttpRequest(String ip) {
    return "<html></html>";
  }

  // hide from other classes, only used internally
  private String findIpAddress(String address) {
    return "127.0.0.1";
  }
}
```

-   By abstracting away complex internal implementation, we have reduced coupling among classes







## Constructor

-   This is wrong:

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112091504751.png" alt="image-20211209150440710" style="zoom:25%;" />

-   All necessary parameters should be set when creating the object 

```java
// A Constructor method 
public Employee(int baseSalary, int hourlyRate) {
    setBaseSalary(baseSalary); // data validation
    setHourlyRate(hourlyRate); // data validation
    numberOfEmployees++;
}

// In so doing, the main class looks like this: 
public static void main (String[] args) {
    var employee = new Employee(50_000, 20);
}
```







## Method Overloading

```java
public int calculateWage(int extraHours) {
    return baseSalary + (getHourlyRate() * extraHours);
}

public double calculateWage(double extraHours) {
    return baseSalary + (getHourlyRate() * extraHours);
}
```







## Constructor Overloading

```java
public Employee(int baseSalary) {
    // reference to the method down below 
    this(baseSalary, 0);
}

public Employee(int baseSalary, int hourlyRate) {
    setBaseSalary(baseSalary);
    setHourlyRate(hourlyRate);
    numberOfEmployees++;
}
```

-   Use ```Command + P``` to see different constructors 

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112091517115.png" alt="image-20211209151741076" style="zoom:25%;" />







## Static Members

-   A class can have two types of members
    -   Instance members 
        -   Belong to instances or objects 
        -   Instance members like variables can be accessed by using  dot operator 
    -   Static members 

















