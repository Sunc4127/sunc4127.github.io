---
title: Inheritance
date: 2021-12-17 16:00:11
permalink: /pages/a38011/
categories:
  - 个人笔记
  - Java
tags:
  - 
---

[toc]

## Inheritance

-   Use ```extends``` to indicate that class A inherits from class B

<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202112171603542.png" alt="image-20211217160340423" style="zoom:25%;" />

## The `Object` Class

-   All classes extends from the `Object` class 
    -   don't  need to state the obvious
    -   i.e. ```public class main extends Object```
-   It provides useful methods 





## `hashCode()` function

-   The ```hashCode()``` methods **returns a numeric value that is calculated based on the address of the object in memory**. 

```java
var point1 = new Point(1, 2); 
var point2 = new Point(1, 2); 
System.out.println(point1.equals(point2)); // false
System.out.println(point1.hashCode() == point2.hashCode()) // false
```

-   Even though point1 and point2 have the same coordinates, the default implementation of the ```equals()``` method compares objects for reference equality. 

-   These two objects are **in two different locations in memory**, that’s why the ```equals()``` method returns `false`. 

    

```java
var point1 = new Point(1, 2); 
var point2 = point1; 
System.out.println(point1.hashCode() == point2.hashCode()); // true
```





## Constructor

-   A ==Default Constructor== is a constructor **without any parameters**
    -   If we don’t create it, the Java compiler will automatically add one to our classes. 

-   i.e. ```public Constomer(String name) {}```
    -   constructors **don’t have a return type, not even void**. 
-   To create a constructor
    -   Click `Code`
    -   Click `Generate`
    -   Click `Constructor`





## The ```super``` keyword

-   The super keyword is a **reference to the base or parent class**. 

-   We can **use it to access the members (fields and methods) or call the constructors of the base class**
-   In contrast, the ```this``` keyword returns a reference to the current object. 

```java
// Super class 
public abstract class UIControl {
  private boolean isEnabled = true;

  public UIControl(boolean isEnabled) {
    this.isEnabled = isEnabled;
  }
}

// Sub class 
public class TextBox extends UIControl {
  private String text = "";

  public TextBox() {
    // pass boolean value to the super class 
    super(true);
  }
}
```



## `Private` and `protected` access modifiers

-   Members marked with protected or private access modifiers are only accessible inside of a class. 

-   **Protected** members are **inherited** and **are accessible by child (derived) classes**. 
    -   If we **omit** the access modifier, the member will have the **default access modifier** which makes that member **public in package**. 
    -   In other words, that member will **be public in the package but private outside of the package**. 
-   **Private** fields cannot be inherited by sub classes and are not accessible outside of the class 
    -   Its implementation detail is hidden





## Method Overriding

-   **Method overriding** means **changing the implementation** of an inherited method in a subclass. 
    -   For example, we can override the ```equals()``` or ```hashCode()``` methods of the Object class. 

-   **Method overloading** means declaring a method with **different signatures** (different number, type and order of parameters).  

```java
public class TextBox extends UIControl {
  private String text = "";
    
  // Override the default toString method
  @Override
  public String toString() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }
}


public static void main(String[] args) {
    var textBox = new TextBox();
    textBox.setText("Hello world");
    
    // Can ignore the '.toStrong()' part 
    System.out.println(textBox);
}
```





## `@Override` annotation

The benefit of applying the ```@Override``` annotation when overriding a method:

-   It **signals the Java compiler that we are overriding a method** in the base class and this helps the compiler check our code for correctness. 

-   It will ensure the **signature** of the method in the subclass **matches** the on declared in the base class. 
-   Also, if we remove this method from the base class, the compiler will let us know and we can remove the method in the subclass as well.



11.   The Customer class inherits from the User class. Can we pass a Customer object to this method? Why?

```java
public void print(User user) {}
```

-   Yes. We can pass an instance of any classes that inherit directly or indirectly from the User class. 
-   In this case, the customer object will get automatically **upcast** (meaning it’ll get converted to its base type - User). 
-   If we need to work with members of the customer object in this method, we need to explicitly **downcast** it by prefixing the object with (Customer).



12.   What is the usage of the ```instanceof``` operator?

-   It **tells us if an object is an instance of a class.** 
-   We use it before casting an object to a different type to make sure we don’t get a casting exception.  



13.   What are the four principles of **object-oriented programming**?

-   **Encapsulation**: **bundling** the data and operations on the data inside **a single unit (class)**.  
-   **Abstraction**: **reducing complexity** by hiding unnecessary details (metaphor: the implementation detail of a remote control is hidden from us. We only work with its public interface.)  
-   **Inheritance**: a mechanism for **reusing** code.  
-   **Polymorphism**: a mechanism that **allows an object to take many forms and behave differently**. This will help us build **extensible** applications. 



14.   When do we use abstract classes?

-   An abstract class is a **partially-implemented** (half-cooked) class. 
-   We **cannot instantiate them**.
-   But we use them to **share** some common code across their subclasses.



15.   Can we have an abstract class without any abstract methods?

-   Yes! 
-   An abstract class does not need abstract methods. 
-   **But if we mark a method as abstract, we should mark the class as abstract as well.**



16.   When do we use ```final``` classes?

-   Final classes **cannot be inherited**
-   We use them when we’ve made certain **assumptions** about a class and we want to **prevent other classes extending our class** and break those assumptions.  



17.   What is the diamond problem?

-   The diamond problem **happens in languages that support multiple inheritance**. 
-   If two classes (B, C) derive from A and are also the parents of another class (D), we see a diamond. 
-   If the top class (A) declares a method (eg toString) and its children (B and C) override this method, it’s **not clear which implementation will be inherited by D.**
-   **Java does not support multiple inheritance** 

 















