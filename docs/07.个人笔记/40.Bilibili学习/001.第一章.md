

[TOC]





## Selection Sort

-   时间复杂度：$O(N^2)$
-   额外空间复杂度：$O(1)$

```java
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j < arr.length; j++) {
            // find the smallest value and move it to the front
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr, i, minIndex);
    }
}

public static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```



## Bubble Sort

-   时间复杂度：$O(N^2)$
-   额外空间复杂度：$O(1)$

```java
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int e = arr.length - 1; e > 0; e--) {
        for (int i = 0; i < e; i++) {
            if (arr[i] > arr[i + 1]) {
                // all swap again 
                swap(arr, i, i + 1);
            }
        }
    }
}
```



## Insertion Sort 

-   最差时间复杂度：$O(N^2)$
-   最好时间复杂度：$O(N)$
-   额外空间复杂度：$O(1)$

```java
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    for (int i = 1; i < arr.length; i++) {
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            swap(arr, j, j + 1);
        }
    }
}
```





## EOR （位运算）

-   EOR 原理：无进位相加，顺序不重要
-   非常快，贼快😎
-   一个整形数列中所有树都是成双成对，只有一个是奇数个
    -   方法就是全都 EOR，结果就是我们要找的那个数

```java
public static void printOddTimesNum1(int[] arr) {
    int eor = 0;
    for (int cur : arr) {
        eor ^= cur;
    }
    System.out.println(eor);
}
```



-   一个整形数列中所有树都是成双成对，只有两个是奇数个

    <img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202207211135595.png" alt="image-20220721113505645" style="zoom:25%;" />

    -   先算出 a 和 b 的 EOR
    -   找到 EOR 第一个为 1 的二进制位，意味着这个位置，a 和 b 不一样
    -   找出所有这个位置为 1 的 数字，计算 EOR‘， 得到 a 或者是 b
    -   EOR ^ EOR'， 得到 b 或者是 a



<img src="https://cdn.jsdelivr.net/gh/Sunc4127/image-hosting/202207211137642.png" alt="image-20220721113710599" style="zoom:25%;" />

```java
public static void printOddTimesNum2(int[] arr) {
    int eor = 0;
    for (int curNum : arr) {
        eor ^= curNum;
    }
    // eor = a ^ b
    // eor != 0
    // eor 必然有一个二进制位置是 1

    // 选最右侧的 1，先取反，然后补码，然后‘与’ （常规操作）
    int rightOne = eor & (~eor + 1);

    int eorHasOne = 0; // eor'
    for (int cur : arr) {
        if ((cur & rightOne) != 0) {
            eorHasOne ^= cur;
        }
    }
    System.out.println(eorHasOne + " " + (eor ^ eorHasOne));
}
```

